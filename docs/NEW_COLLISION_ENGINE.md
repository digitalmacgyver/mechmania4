# New Collision Engine Architecture

This document describes the modernized collision detection and resolution system introduced to fix the multi-hit bugs and non-determinism issues present in the legacy collision engine (see `LEGACY_COLLISION_ENGINE.md`).

## Overview

The new collision system uses a **snapshot-based command pattern** that separates collision detection from collision resolution. This architecture eliminates race conditions, prevents multi-hit bugs, and ensures deterministic behavior across all platforms.

**Key Design Principles:**
- **Immutable Snapshots**: All collision detection operates on immutable state snapshots taken at the start of the frame
- **Command Pattern**: Collision handlers generate commands rather than mutating state directly
- **Deterministic Ordering**: Commands are sorted by priority and world index to ensure reproducible results
- **Multi-Hit Prevention**: Objects can only be killed once per frame, preventing duplicate fragmentation and damage

## Core Components

### CollisionState (team/src/CollisionTypes.h)

An immutable snapshot of an object's state at the time of collision detection:

```cpp
struct CollisionState {
  CThing* thing;              // Pointer to actual object (for command targeting)
  CCoord position;            // Position snapshot
  CTraj velocity;             // Velocity snapshot
  double mass;                // Total mass (hull + cargo + fuel for ships)
  ThingKind kind;             // Object type (SHIP, ASTEROID, STATION, GENTHING)
  unsigned int world_index;   // Deterministic ordering key

  // Ship-specific state
  double ship_shield;         // Current shield level
  bool ship_docked;           // Docking state

  // Asteroid-specific state
  AsteroidType asteroid_material;  // Iron, Nickel, or Ice
};
```

**Why Immutable Snapshots?**
- Prevents race conditions where object A's collision with B affects B's collision with C
- Allows parallel collision detection (future optimization)
- Makes collision behavior easier to reason about and test

### CollisionContext (team/src/CollisionTypes.h)

Provides read-only context for collision handlers:

```cpp
struct CollisionContext {
  CWorld* world;                      // World reference (for game constants)
  const CollisionState* self_state;   // Immutable state of object processing collision
  const CollisionState* other_state;  // Immutable state of collision partner
  double time_step;                   // Physics dt for this frame (usually 1.0)

  // Feature flags (controls legacy vs new behavior)
  bool use_new_physics;               // Elastic collisions vs legacy
  bool disable_eat_damage;            // Damage-free asteroid eating vs legacy damage
  bool use_docking_fix;               // Fixed launch distance vs buggy re-docking

  double random_separation_angle;     // For ship-ship same-position collisions
};
```

### CollisionOutcome (team/src/CollisionTypes.h)

Container for commands and spawn requests generated by a collision handler:

```cpp
struct CollisionOutcome {
  CollisionCommand commands[MAX_COLLISION_COMMANDS];  // Up to 8 commands
  unsigned int command_count;

  SpawnRequest spawns[MAX_SPAWN_REQUESTS];  // Up to 8 spawn requests (asteroid fragments)
  unsigned int spawn_count;

  void AddCommand(const CollisionCommand& cmd);
  void AddSpawn(const SpawnRequest& req);
};
```

### CollisionCommand (team/src/CollisionTypes.h)

Represents a single state change to be applied after all collisions are detected:

```cpp
enum class CollisionCommandType {
  kKillSelf,           // Mark object dead
  kSetDocked,          // Dock ship at station
  kSetVelocity,        // Update velocity
  kSetPosition,        // Update position
  kAdjustShield,       // Apply damage/healing
  kAdjustCargo,        // Transfer cargo
  kAnnounceMessage     // Send message to announcer
};

struct CollisionCommand {
  CollisionCommandType type;
  CThing* target;              // Object to apply command to
  CTraj velocity;              // For kSetVelocity
  CCoord position;             // For kSetPosition
  double value;                // For kAdjustShield, kAdjustCargo
  char message_buffer[256];    // For kAnnounceMessage (owned buffer, no dangling pointers!)
};
```

**Command Priority Order** (from highest to lowest):
1. `kKillSelf` - Must execute first to prevent dead objects from processing further commands
2. `kSetDocked` - Docking teleports ship to station center, affects subsequent position updates
3. `kSetVelocity` - Physics updates before damage calculations
4. `kSetPosition` - Position updates before announcements
5. `kAdjustShield` - Damage/healing before cargo transfers
6. `kAdjustCargo` - Cargo transfers before announcements
7. `kAnnounceMessage` - Informational messages last

## Pipeline Stages

The new collision system processes collisions in five deterministic stages:

### Stage 1: Snapshot All Objects

```cpp
// Create immutable snapshots of all live objects
std::unordered_map<CThing*, CollisionState> snapshots;
for (each live object in world) {
  snapshots[object] = object->MakeCollisionState();
}
```

**Key Method**: `CThing::MakeCollisionState()` (implemented in Thing.C, Ship.C, Asteroid.C, Station.C)

### Stage 2: Detect Collisions

```cpp
// Build collision pairs using snapshot data only
std::vector<CollisionPair> collisions;
for (each team object) {
  for (each world object) {
    if (snapshots[obj1].overlaps(snapshots[obj2])) {
      collisions.push_back({obj1, obj2, overlap_distance});
    }
  }
}
```

**Overlap Detection**: Uses `CThing::Collide(CThing*)` which checks `Distance() < (radius1 + radius2)`

**Deduplication**: Collision pairs are canonicalized using world indices to prevent processing both (A,B) and (B,A):

```cpp
// Canonicalize pair: always (lower_index, higher_index) order
if (obj1->GetWorldIndex() > obj2->GetWorldIndex()) {
  std::swap(obj1, obj2);
}
```

### Stage 3: Generate Commands

```cpp
// Generate commands from BOTH perspectives for each collision
for (each collision pair (obj1, obj2)) {
  // Build contexts (both objects get same random angle for determinism)
  CollisionContext ctx1(world, &snapshots[obj1], &snapshots[obj2], dt, flags...);
  CollisionContext ctx2(world, &snapshots[obj2], &snapshots[obj1], dt, flags...);

  // Generate commands from both perspectives
  CollisionOutcome out1 = obj1->GenerateCollisionCommands(ctx1);
  CollisionOutcome out2 = obj2->GenerateCollisionCommands(ctx2);

  // Collect all commands and spawns
  all_commands.insert(out1.commands);
  all_commands.insert(out2.commands);
  all_spawns.insert(out1.spawns);
  all_spawns.insert(out2.spawns);

  // Track pending kills to prevent multi-hit bugs
  for (each kKillSelf command) {
    pending_kills.insert(command.target);
  }
}
```

**Multi-Hit Prevention**: Once an object has a pending `kKillSelf` command, it's skipped in all subsequent collision pairs:

```cpp
// Skip if either object has a pending kill command
if (pending_kills.count(obj1) > 0 || pending_kills.count(obj2) > 0) {
  continue;  // Don't generate additional commands for dead objects
}
```

### Stage 4: Sort Commands by Priority

```cpp
// Sort commands: Kill > SetDocked > SetVelocity > SetPosition > AdjustShield > AdjustCargo > Announce
std::sort(all_commands.begin(), all_commands.end(),
  [](const CollisionCommand& a, const CollisionCommand& b) {
    return GetCommandTypePriority(a.type) < GetCommandTypePriority(b.type);
  });
```

**Why This Order Matters**:
- Kills must execute first so dead objects don't receive damage, cargo, or position updates
- Docking must execute before velocity/position updates (docking teleports ships to station center)
- Announcements execute last (informational only, no gameplay impact)

### Stage 5: Apply Commands

```cpp
// Apply commands in sorted order
for (each command in all_commands) {
  command.target->ApplyCollisionCommand(command, apply_ctx);
}

// Spawn new objects (asteroid fragments)
for (each spawn in all_spawns) {
  CAsteroid* fragment = new CAsteroid(spawn.mass, spawn.material);
  fragment->SetPosition(spawn.position);
  fragment->SetVelocity(spawn.velocity);
  world->AddThingToWorld(fragment);
}
```

**Key Method**: `CThing::ApplyCollisionCommand(const CollisionCommand&, const CollisionContext&)` (virtual, implemented in Thing.C, Ship.C, Asteroid.C, Station.C)

## Bug Fixes

### Multi-Hit Prevention

**Problem**: In legacy mode, asteroids could be hit multiple times in one frame, spawning 6+ fragments instead of 3.

**Solution**: Track `pending_kills` during command generation (Stage 3):

```cpp
std::set<CThing*> pending_kills;

for (each collision pair) {
  // Skip if either object already marked for death
  if (pending_kills.count(obj1) > 0 || pending_kills.count(obj2) > 0) {
    continue;
  }

  // Generate commands...

  // Track new kills
  for (each kKillSelf command) {
    pending_kills.insert(command.target);
  }
}
```

**Result**: Each asteroid fragments exactly once, regardless of how many ships/lasers hit it.

### Deterministic Collision Ordering

**Problem**: Legacy mode used pointer comparison for canonicalization, causing non-reproducible behavior across runs and platforms.

**Solution**: Use world indices for canonicalization (Stage 2):

```cpp
// Canonicalize pair: Use world index for deterministic ordering
if (obj1->GetWorldIndex() > obj2->GetWorldIndex()) {
  std::swap(obj1, obj2);
}
```

**Result**: Collision pairs are always processed in the same order, making game outcomes fully reproducible.

### Destruction Announcements

**Problem**: Legacy mode didn't announce when ships were destroyed by asteroids or other ships.

**Solution**: Generate `kAnnounceMessage` commands when shield drops to zero:

```cpp
// In Ship::GenerateCollisionCommands()
if ((self_state->ship_shield - damage) <= 0.0 && ctx.world) {
  char msg[256];
  snprintf(msg, sizeof(msg), "%s destroyed by %s",
           self_state->thing->GetName(), other_state->thing->GetName());
  outcome.AddCommand(CollisionCommand::Announce(msg));
}
```

**Note**: Stack-allocated `msg` is safe because `CollisionCommand::Announce()` copies the string into the command's owned `message_buffer`.

### Fragment Mass Conservation

**Problem**: Early implementation incorrectly added laser mass to asteroid fragments, violating mass conservation.

**Solution**: Fragments inherit only the original asteroid's mass:

```cpp
// Correct: fragments total original asteroid mass
double fragment_mass = self_state->mass / 3.0;

// For each of 3 fragments:
outcome.AddSpawn(SpawnRequest(fragment_mass, ...));
```

**Physics**: Laser momentum is absorbed (inelastic collision), but laser mass is NOT added to fragments. Photons have momentum (p = E/c) but negligible rest mass.

## Physics Models

### Elastic Collisions (Ship-Ship, Large Asteroid-Ship)

**Conservation Laws**:
- Momentum: `m₁v₁ + m₂v₂ = m₁v₁' + m₂v₂'`
- Kinetic Energy: `½m₁v₁² + ½m₂v₂² = ½m₁v₁'² + ½m₂v₂'²`

**Implementation** (Ship.C, HandleElasticShipCollision):

```cpp
// Standard 2D elastic collision formulas
CTraj v1_parallel = ProjectOntoNormal(self_vel, collision_normal);
CTraj v2_parallel = ProjectOntoNormal(other_vel, collision_normal);

CTraj v1_perp = self_vel - v1_parallel;
CTraj v2_perp = other_vel - v2_parallel;

// Exchange parallel components (perpendicular unchanged)
double m1 = self_state->mass;
double m2 = other_state->mass;

CTraj v1_final = v1_perp + ((m1 - m2) * v1_parallel + 2 * m2 * v2_parallel) / (m1 + m2);
CTraj v2_final = v2_perp + ((m2 - m1) * v2_parallel + 2 * m1 * v1_parallel) / (m1 + m2);
```

**Collision Damage** (symmetric for both ships):

```cpp
// Damage based on momentum change (both ships take equal damage)
double momentum_change = CalculateCollisionMomentumChange(ctx);
double damage = momentum_change / g_laser_damage_mass_divisor;  // 1000.0
```

**Why symmetric?** Both ships experience equal and opposite momentum changes (Newton's 3rd law), so both should take equal damage.

### Inelastic Collisions (Laser-Ship, Laser-Asteroid, Eating Asteroids)

**Conservation Laws**:
- Momentum: `m₁v₁ + m₂v₂ = (m₁ + m₂)v_final`
- Kinetic Energy: **NOT conserved** (energy lost to heat/deformation)

**Implementation** (perfectly inelastic):

```cpp
// Objects stick together (or absorb each other)
CTraj momentum_total = self_state->velocity * self_state->mass +
                       other_state->velocity * other_state->mass;
double mass_total = self_state->mass + other_state->mass;
CTraj v_final = momentum_total / mass_total;
```

**Examples**:
- **Ship eats small asteroid**: Ship absorbs asteroid mass and momentum
- **Laser hits ship**: Ship absorbs photon momentum (laser mass ≈ 0)
- **Laser hits asteroid**: Asteroid absorbs photon momentum, fragments if laser strong enough

### Momentum Conservation in Fragmentation

**Question**: When an asteroid fragments into 3 pieces with 120° spread pattern, is momentum conserved?

**Answer**: YES! The three spread vectors sum to zero:

```
Spread directions: 0°, 120°, 240°
v₁ = v_spread * (cos 0°, sin 0°)     = (v_spread, 0)
v₂ = v_spread * (cos 120°, sin 120°) = (-v_spread/2, v_spread√3/2)
v₃ = v_spread * (cos 240°, sin 240°) = (-v_spread/2, -v_spread√3/2)

Sum: v₁ + v₂ + v₃ = (0, 0) ✓
```

Because the spread pattern sums to zero, total momentum is:

```
Total momentum = 3 * fragment_mass * v_center_of_mass
               = (3 * original_mass/3) * v_center_of_mass
               = original_mass * v_center_of_mass ✓
```

**Note**: Kinetic energy is NOT conserved (fragments fly faster after high-energy impacts). This is intentional gameplay tuning - spread velocity scales with impact energy.

## Feature Flags

The new collision system coexists with legacy behavior via runtime feature flags:

### `collision-handling` (default: true)

- **New**: Snapshot-based command pipeline with multi-hit prevention
- **Legacy**: Original collision loop with multi-hit bugs

**Command-line**:
```bash
./mm4serv --legacy-collision-handling  # Enable multi-hit bugs for testing
```

### `physics` (default: true)

- **New**: Proper elastic/inelastic collision physics with momentum conservation
- **Legacy**: Historical collision physics (non-physical separation impulses, asymmetric damage)

**Affects**:
- Ship-ship collision physics and damage
- Ship-asteroid collision physics and damage
- Laser-ship momentum transfer
- Laser-asteroid fragmentation physics
- Jettison recoil (2x multiplier bug in legacy)
- Laser velocity model (target-tracking vs 30 u/s photon velocity)

**Command-line**:
```bash
./mm4serv --legacy-physics  # Use historical collision physics
```

### `disable_eat_damage` (default: true)

- **New**: Ships take NO damage when eating small asteroids (free lunch!)
- **Legacy**: Ships take full collision damage even when eating

**Command-line**:
```bash
./mm4serv --legacy-asteroid-eat-damage  # Ships damaged when eating
```

### `docking` (default: true)

- **New**: Fixed safe launch distance = 48 units (station_radius + ship_radius + ship_radius/2)
- **Legacy**: Buggy distance = dDockDist + 5.0, causes re-docking with low thrust

**Command-line**:
```bash
./mm4serv --legacy-docking  # Enable re-docking bug
```

### All-Legacy Mode

Enable all legacy behaviors with a single flag:

```bash
./mm4serv --legacy-all
```

Equivalent to:
```bash
./mm4serv --legacy-collision-handling \
          --legacy-physics \
          --legacy-asteroid-eat-damage \
          --legacy-docking
```

## Testing

### Test Harness

The Python test harness in `scripts/test_collision_modes.py` runs games in both legacy and new modes and compares results:

```bash
# Quick test with groogroo AI teams
python3 scripts/test_collision_modes.py

# Test with specific teams
python3 scripts/test_collision_modes.py --team1 noop --team2 testteam

# Test with specific collision scenario
python3 scripts/test_collision_modes.py \
  --team1 noop \
  --team2 testteam \
  --test-file teams/testteam/tests/test1_ship_station_collision.txt
```

### Collision Test Scenarios

Pre-built test scenarios in `teams/testteam/tests/`:

**Test 1: Ship-Station Collision** (`test1_ship_station_collision.txt`)
- Ship thrust toward station, tests docking vs collision
- Legacy: 4 collisions (re-docking bug)
- New: 1 collision (fixed safe distance)

**Test 2: Laser-Station Collision** (`test2_station_laser_collision.txt`)
- Ship fires laser at station
- Both modes: 1 hit (stations immune to lasers, no damage)

**Test 3: Ship-Ship Collision** (`test3_ship_ship_collision.txt`)
- Two ships collide head-on
- Legacy: 20 collisions (symmetry spam bug)
- New: 3 collisions (deterministic deduplication)

**Test 4: Ship-Asteroid Collision** (`test4_ship_asteroid_collision.txt`)
- Ship collides with random asteroids (300 turns, full game)
- Tests eating vs fragmentation vs damage

**Test 5: Laser-Ship Collision** (`test5_ship_laser_collision.txt`)
- Ship fires laser at enemy ship
- Both modes: 4 hits
- Tests momentum transfer and damage

### Creating Custom Test Scenarios

Create a text file with format:
```
# shipnum,turn,ORDER_KIND,magnitude
0,1,THRUST,100.0
1,2,TURN,1.57
2,3,JETTISON,5.0
3,4,LASER,50.0
```

See `teams/testteam/tests/USAGE.md` for detailed documentation.

### Verifying Correctness

**Momentum Conservation Test**:
```bash
# Run with verbose logging
./mm4serv --verbose | grep "MOMENTUM"

# Should see conservation within floating-point error
```

**Multi-Hit Prevention Test**:
```bash
# Legacy mode should show multi-fragmentation
./mm4serv --legacy-collision-handling --verbose | grep "Fragment"

# New mode should show single fragmentation
./mm4serv --verbose | grep "Fragment"
```

**Determinism Test**:
```bash
# Run same scenario twice, compare logs
./mm4serv --seed 42 > run1.log
./mm4serv --seed 42 > run2.log
diff run1.log run2.log  # Should be identical
```

## Future Work

**Performance Optimizations**:
- Parallel collision detection (snapshots are immutable, thread-safe)
- Spatial partitioning (quad-tree or grid) for O(n²) → O(n log n) collision detection
- SIMD-accelerated distance calculations

**Feature Enhancements**:
- Partial damage for glancing blows (angle-dependent damage multiplier)
- Spin/rotation from off-center collisions (torque = r × F)
- Continuous collision detection (sweep-based CCD for fast-moving objects)

**Code Quality**:
- Unit tests for collision physics formulas
- Fuzz testing for edge cases (same position, same velocity, zero mass)
- Determinism verification across platforms (Linux, macOS, Windows)

## References

- Legacy collision bugs: `LEGACY_COLLISION_ENGINE.md`
- Implementation guide: `CLAUDE.md` (Simple Method Dispatch section)
- Team API: `TEAM_API.md`
- Test harness: `scripts/QUICK_TESTING.md`
