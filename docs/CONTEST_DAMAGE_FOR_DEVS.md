# Contest Damage Reference (Developers)

> **Scope.** This document covers the **default modern damage model**. Legacy compatibility flags restore the 1998 balance (asymmetric damage, laser exploits, etc.) and are intentionally excluded here.

## 1. Shield System
- **Capacities:** `g_ship_default_shield_capacity` (8000). Captured in `CollisionState::ship_shield_capacity`.
- **Charging:** `O_SHIELD` processed before thrust each slice. Fuel spent = requested shield delta (clamped to available fuel). Shields clamp to `[0, capacity]`.
- **Destruction:** When `ship_shield <= 0` after applying commands, the ship sets `DeadFlag = true` (triggered in `CShip::ApplyCollisionCommandDerived` on `kAdjustShield`).

## 2. Collision Damage Formula
For any collision where damage applies, each participant takes:
```
damage = |Δp| / g_laser_damage_mass_divisor
```
where `|Δp|` is the magnitude of the momentum change experienced by that object, and `g_laser_damage_mass_divisor` defaults to 1000.0.

**Damage to shield conversion:** 1000 damage = 1 shield unit depleted

### 2.1 Elastic collisions
- **Ship ↔ Ship**, **Ship ↔ large Asteroid**:
  - Uses analytic solution from `CalculateElastic2DCollision`.
  - Momentum conserved, kinetic energy conserved.
  - Δp is derived from the post-collision velocities returned by the solver.

### 2.2 Inelastic collisions
- **Ship ↔ small Asteroid (fits)**:
  - Ship absorbs asteroid; final velocity is `(m₁ v₁ + m₂ v₂) / (m₁ + m₂)`.
  - Energy is not conserved. No shield damage is emitted when `ctx.disable_eat_damage` is true (default).

### 2.3 Laser impacts
- Laser event synthesises a virtual object with mass `beam_remaining × g_laser_mass_scale_per_remaining_unit`.
- **Damage formula:** `damage = mass = beam_remaining × 30.0` (with default scale)
  - **Example:** A beam with 100 units remaining deals 3000 damage
- **Shield depletion:** `shields_lost = damage / 1000` (so 3000 damage = 3.0 shield units)
- **Vinyl depletion:** `vinyl_lost = damage / 1000` (for station hits)
- **Asteroid threshold:** Asteroid shatters if `damage ≥ 1000`
- On ships (new physics mode) the beam is merged inelastically: final velocity `v_final = (m_ship v_ship + m_beam v_beam) / (m_ship + m_beam)`.
- On stations the command is `kAdjustCargo` (subtract vinyl). On asteroids, `kKillSelf` + fragment commands fire if damage ≥ 1000.

## 3. Fragmentation Rules
- `g_thing_minmass = 3.0`. If `asteroid_mass / 3 < g_thing_minmass` the asteroid disappears instead of fragmenting.
- Fragment velocities are generated by taking the relative velocity magnitude as spread speed and adding either the centre-of-mass (laser) or elastic-post velocity (ship).
- All fragments inherit the parent material.

## 4. Docking & Immunity
- Docking commands (`kSetDocked`) mark the ship docked in both the live object and the mutable snapshot. Once docked, subsequent collisions (same frame) are filtered unless the partner is the home station.
- Docked ships cannot take collision or laser damage (laser firing is disallowed; collision pairing is skipped).

## 5. Laser Damage Workflow
1. `World::LaserModelNew()` iterates all firing ships (both teams).
2. For each beam it:
   - Builds `LasThing` (temporary `CThing`) with position near the target, mass = remaining beam energy, velocity along the beam (speed = `g_game_max_speed`).
   - Calls `pTarget->Collide(&LasThing, this)` which routes to collision handlers.
3. The target’s `GenerateCollisionCommands` emits shield/cargo adjustments plus optional kills.
4. Commands are applied immediately (not deferred like regular collisions) because lasers occur after the last physics slice.

## 6. Constants Summary

All constants are defined in `team/src/GameConstants.h` and initialized in `team/src/GameConstants.C`.

| Constant | Default | Role |
| --- | --- | --- |
| `g_laser_damage_mass_divisor` | 1000.0 | Converts damage to shield/vinyl units (1000 damage = 1 unit). |
| `g_laser_mass_scale_per_remaining_unit` | 30.0 | Damage per unit of remaining beam length. |
| `g_laser_range_per_fuel_unit` | 50.0 | Laser length purchased per ton of fuel. |
| `g_ship_default_shield_capacity` | 8000.0 | Upper limit for shields (in shield units). |
| `g_ship_collision_bump` | 3.0 | Separation padding after ship collisions. |
| `g_thing_minmass` | 3.0 | Minimum fragment size. |
| `g_asteroid_laser_shatter_threshold` | 1000.0 | Minimum damage to shatter an asteroid. |

**Key conversions:**
- Laser damage: `damage = 30.0 × (beam_length - distance_to_target)`
- Shield loss: `shields_lost = damage / 1000`
- Vinyl loss: `vinyl_lost = damage / 1000`
- Asteroid shatter threshold: `damage ≥ 1000`

## 7. Implementation Touchpoints
- Collision damage issuance resides in `CShip::GenerateCollisionCommands` (ship perspective) and `CAsteroid::GenerateCollisionCommands`.
- Shield application occurs in `CShip::ApplyCollisionCommandDerived`.
- Station cargo changes on lasers/deliveries are handled by `CStation::ApplyCollisionCommandDerived`.
- Mutable snapshot updates for resource deltas live in `apply_command_to_state` (`World.C`). **Any new resource-affecting command must update this helper.**

## 8. Testing
- The regression scripts in `teams/testteam/tests/test[1-5].sh` cover ship-station, station-laser, ship-ship, ship-asteroid, and ship-laser scenarios in both legacy and new modes.
- For focused physics checks, `scripts/test_collision_modes.py` runs paired games and emits server/testteam logs for manual inspection.

For a player-facing overview, see `CONTEST_DAMAGE_FOR_CONTESTANTS.md`. For collision ordering and physics background, consult `CONTEST_PHYSICS_FOR_DEVS.md` and `docs/NEW_COLLISION_ENGINE.md`.
