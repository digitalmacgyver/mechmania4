# This is a scratchpad of everything I'm considering for this
# project. Please ignore.

Best parameters saved to: EvoAI_params_best_pid499368.txt

Optimization finished.
Best fitness achieved: 198.83
Best parameters saved to: /home/viblio/coding_projects/mm_claude/teams/evo/output/EvoAI_params_best_pid563522.txt

Optimization finished.
Best fitness achieved: 93.33
Best parameters saved to: /home/viblio/coding_projects/mm_claude/teams/evo/output/EvoAI_params_best_pid609893.txt

/home/viblio/coding_projects/mm_claude/teams/evo/output/EvoAI_params_best_pid609893.txt

/home/viblio/coding_projects/mm_claude/teams/evo/output/EvoAI_params_best_pid974292.txt

== EVO Combat ==

For our next improvements:

1. Consider "laser efficiency" when planning laser shots. Lasers have
a maximum beam length of 512. Note that a laser of beam length B
consumes fuel of B/50 to create. When it strikes a target D distance
away it deals: 30*(B-D) damage units to that target. For target ships
their shields are depleted at a rate of 1/1000th of a shield per that
damage unit. For target stations their vinyl reserves are deleted at a
rate of 1/1000th of a ton of vinyl per that unit of damage.  Note that
ships can restore shields by X per X tons of fuel consumed. This means
that when computing whether a shot beam costs more fuel to shoot than
it does for an enemy ship to regenerate shields, we can consider the
math above to come up with an efficiency ratio. This works out to
roughly that a beam B should be at least 3*D long in order that it not
cost the shooter more fuel to generate the beam than it does for the
target ship to regenerate shields.  There are of course other
conditions - but generally we should be aware that, for example, the
fuel cost to reduce 1 unit of shields from an enemy ship or 1 ton of
vinyl from an enemy station is highly dependent on our distance D from
the target.

Laser Efficiency considerations should be balanced against other
relavant data such as: the hunter's current fuel reserves, the targets
ships shields or staions vinyl reserves, whether there is any free
uranium left in the world, and whether the game is nearly over (the
game is ~300 game seconds long at which point it ends).

2. Add logic to avoid "overkill" with lasers. A ship with X shields is
destroyed when its shields reach 0 - so there is no point in deling
much, much more than X damage to it (it is OK to deal a little bit
more to account for imprecision in our plans versus reality when the
game engine simulates the physics results). Similarly a station with X
vinyl on it can not be taken below 0 vinyl - it is wasteful to shoot
it with much more power than would reduce the vinyl reserves to 0.

2. Consider dynamically switching between hunter and gatherer mode for
ships depending on world state information.

Here are some relevant world state variable to consider:

a. (no undocked enemy ships && ! enemy station has vinyl ) ; we might call this case "no hunting targets"
b. (no living enemy ships && ! enemy station has vinyl ) ; we might call this condition "there will never be hunting targets )
c. (no living enemy ships with current fuel && ! enemy station has vinyl ) ; we might call this condition "there will probably never be hunting targets"
d. (no vinyl free in the world && ! friendly ships have vinyl cargo ) ; we might call this condition "probably no more points" (in theory an emeny ship could have vinyl and jettison it back into the world, but this is unlikely).
e. (no uranium free in the world) ; we might call this condition "fuel constrained" - at this point ships will never get more fuel - so logic around fuel reserves might need to be changed so we don't end the game with unused fuel we refused to touch.
f. (no uraniam free in the world && no vinul free in the world ) ; For friendly ships that don't have vinyl cargo - the only useful thing to do is most likely to attack enemy ships or ensure vinyl in friendly ships makes it back to the station
g. game clock is approaching 300. The game ends when the internal game clock reaches its 300th turn. Since it takes ~30 turns to nagivate to any point on the map and do something, final strategic and tactical manouvers should begin around turn 270 if not indicated by prior world states. There is no benefit to having exceess fuel at the end of the game.

The key insight is that all ships which can contribute to gathering activites should probably do so when there are no hunting targets, and all ships that can contribute to hunting activities should probablyu do so when there is no more points to be gathered.


== Evo Combat ==

Great work, now we turn to putting some knobs into our system for
combat for the genetic algorithm to work over.

Consider the following baseline information:

Ships have an initial configuration between fuel and cargo space that
sums to 60 tons.

The more initial fuel capacity setting a ship has the more more
suited to combat / aggressive behaviors it is because:
a. It starts off with more fuel (ships begin with full fuel reserves)
b. It is more capable of holding large amounts of fuel, which are necessary for powerful laser shots.
c. Particularly if its fuel capacity is at least 40.0, it can theoretically consume the largest fuel asteroid available in the game world.

On the contrary, the more initial cargo capacity a ship has the more
it is suited to gathering vinyl for endgame victory points because:
a. It can fit more in its cargo hold in one round trip, reducing the
time spent and fuel costs of moving back and forth to the station to
 gather vinyl.
b. Particularly if its cargo capacity is at least 40.0, it can theoretically consume the largest vinyl asteroid available in the game world.

Note that in sizing these relative regions, the interesting capacities
tend to be multiples of 40/9. This is because initial asteroids are
mass 40, and when they are shattered they become mass 40/3, and when
those are shattered they become mass 40/9, and when those are
shattered they are destroyed utterly - so the smallest game object a
ship is _likely_ to encounter is mass 40/9. (The actual smallest
possibly object is mass 3).

Consider in EvoAI among the various behavior modes a ship should be able to act out are:
* Hunter mode - focused on destroying enemy ships, depleting vinyl reserves of enemy bases, and collecting uranium fuel to do so
* Gatherer mode - focused on collecting vinyl, and to a lesser extend uranium

And consider among the 4 ships on the team, those with higher fuel amounts, fuel capacities, and lower cargo amounts and capacities are more suited to the "Hunter" behavior, whereas the opposite are more suited to the "Gatherer" behavior.

Review the attached code for ChromeFunk and extract some of the "Hunter" behavior - notably the logic in stalker and shooter. Combine this with the excellent pathfinding already present in Groogroo. When a ship enters hunter mode "stalk" towards the target, and then shoot once close enough.

However:
a. Use the existing / Groogroo based magic bag based navigation to close on targets.
b. Apply friend or foe detection! Never shoot friendly ships or friendly bases! Never intentionally choose them as targets!
c. Generally ignore asteroids in terms of shooting them - it tends to be a waste of fuel to shoot them (rather just collide, break them up, and then raise shields if shields have gotten too low is more fuel effieenct).

At the end of this round of updates we'll have:

a. An EvoAI with solid navigation and gatherer logic from Groogroo.
b. Rudiementary / Basic hunter logic from Chromefunk.
c. Knobs and settings for the GA algorithm to work will to improve both.



== Evo Stuff ==

We have been working on developing a genetic algoritm improving team
for a coding contest.

The coding contest features two opposed teams of four ships in a
toroidal 2d world from [-512,512) in both X and Y.

Ships travel through the area under newtonian physics and have:
* An orientation (which way they are facing)
* A position and a velocity

Ships may issue orders once each game turn including:

Exactly one of these three exclusive orders:
* Thrust forwards (along their orientation) or backwards (the opposite direction) which changes their velocity by the thrust magnitude. The ship will continue to drift at the new velocity until it thrusts again or collides with something. Thrusting requires fuel which it consumes.
* Rotate: changes the orientation of the ship by the requested amount of radians (normalized onto -pi to pi). Rotation requires fuel which it consumes.
* Jettison either fuel (uranium) or cargo (vinyl)

And also none, one, or both of these exclusive orders:
* Increase the amound of shields a ship has. Ships lose shields from collisions with other ships, with asteroids they can't "eat" or gather, and by being struck with lasers. If a ships shields reach 0 it is destroyed. Raising shields requires fuel which it consumes.
* Shoot lasers. Lasers are emitted along the orientation of the ship and go a beam length specified by the magnitude. Lasers strike and damage the first item they hit along their path, and their damage is proportional to their beam length minus the distance from the firing ship to the hit target. Laser damage reduces shield of ships it hits, and reduces vinyl stores (victory points) of stations it hits. Lasers require fuel which it consumes. NOTE: Lasers fire _AFTER_ any Thurst or Rotation orders from the same turn are processed - so you can turn and shoot on the same turn and your rotation will change where the laser goes.

Ships travel around the game world collecting vinyl (victory points) and uranium (fuel) asteroids. There are initially 5 of each asteroid type of 40 tons each. If a ship collides with an asteroid and has enough fuel or cargo capacity to hold the asteroids mass, it adds it to the respective cargo or fuel. Otherwise it crashes into the asteroid in a perfectly elastic collision, takes some damage, and the asteroid is either broken into 3 equal size pieces, or destroyed if those pieces would be of size less than 3 tons.

When ships dock at a station, friendly or enemey, any vinyl cargo they carry is immediately removed and added to the reserves of that station, where they count as victory points at game end (vinyl inside a ship is not worth any points at game end).

Ships dock by colliding with a station - when this happens their velcoity is set to zero, their position is set to the stations position, all vinyl is added to the sations vinyl and removed from the ship.

Ships may rotate and thrust without spending fuel from a docked state. Thrusting while docked undocks the ship.

While docked ships may not collided with nor take damage from lasers.

While docked ships may not jettison or shoot lasers.

NOTE: Ships are not refuelled while docked. The only ways to get fuel are:
a. When ships are initially created their fuel tanks are filled to capacity. (Teams must decide once at initialization time for each ship they have how much fuel, and how much cargo capacity the ship can have. These two values must both be >= 0 and sum to 60 tons.

b. By colliding with uranium asteroids which are smaller than or equal to the ships fuel capactiy - current fuel.

END SUMMARY OF GAME

With that as preamble, we've been struggling to get our EvoAI.C team to operate in a good enough way that the Genetic algorithm can take off and begin actually improving things. In current testing the EvoAI team basically seems to issue random orders, rarely converges on meaningful targets or achieves any goals (harvest vinyl for victory points, gain fuel for future ship operations, damage enemy ships or stations, etc.).

We're going to begin again:

1. Clear out EvoAI.C of any _implementation_ of logic, but leave in place the decision skeleton, e.g. a place where goals are set, and calls are made to implement those goals, but for now just place inside those implementation comments like:

//Path finding logic to generate the best navigation order this turn goes here.

or

//Determine if we can rotate to face and shoot this turn an enemy station with vinyl to deplete their endgame victory points, while maintaining an emergency fuel reserve for future ship operations.

2. Review the contest rules in the .md file I've uploaded, and the Server logic in ServerCombined.cpp for a general overview of how ships and stations behave.

3. Incorporate Team Groogroo's base NAVIGATION logic into EvoAI, including its:
 * Depth first travesal of 1 and 2 order navigation sequences to bring our ship onto a collision course with each game world object
 * Decision making about whether to pursue HOME VINYL or URANIUM asteroids which prioritizes gathering VINYL (victory points) and returning home, or pursue URANIUM (fuel) for future ship operations.
 * Ignore _most_ of team Groogroo's emergency collision orders logic, but retain:
   * It's shield maintenance procedures which keep the shields at a safe level while retaining a minimal fuel reserve
   * It's jettison logic when approaching enemy stations so as not to accidentally award the enemy victory point granting vinyl if we should collide with an enemy station

After this update team EvoAI should have a solid _navigational_ and _resource gathering_ foundation to build on. In future updates we will worry about other elements of the game, such as combat - but for now lets get navigation and resouce gathering down and in a state where the GA algorithms can improve on that baseline.


=== GrooReview ===

We are ready for another round of code reviews.

I have attached the latest simulator design docs in the docs.md
file, and updated project code in the .cpp files.

In addition the the checks requested below, perform a standard battery
of C/C++ static analysis checks such as those in the style of the ones
offered by Coverity, Black Duck, Clockwork, etc. (e.g. use after free,
inconsistent access of potentially null pointer after checks, and so
on).

We're going to conduct a code review for a portion of a codebase that
runs team Groonew in a simple 2d toroidal starship exploration and
combat game for a coding contest. Team Groonew has 4 ships which it
can issue order to once a second. These orders are designed to achieve
the game goals of returning vinyl to team Groonew's base, and removing
vinyl from the opposing teams base (by shooting it with lasers), and
potentially destroying or damaging opposing team ships.

The purpose of this review is to make sure the GrooNew's
implementation matches it's own internal comments for what it's
supposed to be doing, and is using game APIs correctly.

In particular we want to make sure it's pathfinding is toriodally
aware so that if, for example, one of Team Groonew's ships is trying
to intercept a target M, and:

Both are on the the y=0 worldline, with:
ship position = -300, 0
target position = 300, 0
Ship velocity = 30 to the right
Target velocity = 30 to the left

We correctly figure out that the fastest intercept is to stay on our
current path (which is closing at 60 units per second), rather than
chase the target as it recedes from us by following the shorter (424
distance around the world boundary) distance (Note: the world speed
limit for all objects is 30 units per second).

The key point here is we are ONLY reviewing the Team Groonew's code -
some server code is provided for context, but we can only change the
code related to Team Groonew, it's pathfinding, GetVinyl, MagicBag,
Pathinfo, FuelTraj, etc.

Review this code for:

1. Errors in pathfinding, going the wrong way, over or undershooting,
etc.

2. Essential agreement between comments and code (e.g. if a comment
says "//shoot it!" we should be issuing an O_LASER command at some
point soon.

3. General errors like: Sign errors, inequality wrong direction
errors, extensive computations whose values are never used, etc.

After we identify and fix crucial bugs I'll ask you for help
rearchitecting and simplifying the code for improved elegance - but
for now leave architectural or design issues for later and focus on
bugs/errors that will lead to bad gameplay results.

Please report a list of detected issues, and for each issue include a
brief summary of the problem, the relevant line numbers / triggering
conditions, etc.. Each issue you flag will become an issue for a
developer to fix so include the correct level of detail that a
developer could address it.

==

We've implemented a large refactoring change in the current code
base. The changes are in the tracked but uncommitted files.

Review these changes and check for:

1. Functionally identical - the task here was to refactor to increase
  readability and ease of maintenance - no functionality should
  change. Is this the case for these changes?
 
2. No interaction with legacy code paths - the legacy code paths
  enabled by various --legacy parameters and guarded by various
  conditional checks of those settings should not have changed
  functionally in any way as a result of these changes. Is that the
  case for these changes?

==

We are ready for another round of code reviews.

I have attached the latest requirements / design docs in the docs.md
file, and updated project code in the .cpp files.

In addition the the checks requested below, perform a standard battery
of C/C++ static analysis checks such as those in the style of the ones
offered by Coverity, Black Duck, Clockwork, etc. (e.g. use after free,
inconsistent access of potentially null pointer after checks, and so
on).

We're going to conduct a code review for a portion of a codebase that
simulates a simple 2d toroidal starship exploration and combat game
which is the basis for a coding contest.

The purpose of this review is to make sure the implementation matches
the requirements, features, and interfaces described in docs.md.

The code path we care about begins in:

Server's Simulation() method which iterates and calls World's
PhysicsModel()

PhysicsModel() in turn calls the Drift() method on each thing in the
world, and then resolves collisions via CollisionEvaluation()

Things in the word are polymorphic types derived from CThing and are
one of:

CAsteroids CShips CStations

Or generic things (GENTHING) which are used to implement short lived
laser beams.

The key point here is for this code review we are ONLY reviewing the
Server Side implementation of the game physics, collision handling
system, etc. to ensure it meets the specifications in the docs. We
needn't worry about client state or anything like that - we can treat
it as a black box.

The second key point is there is a default mode of operation, and a
LEGACY mode, enabled with various --legacy command line flags. This
review is ONLY of our default modes - consult the the default in
ArgumentParser.C - IGNORE AND DO NOT REVIEW ANY CODE PATHS NOT ACTIVE
BY DEFAULT.

Review this code for:

1. Correctness in the physics model - watch for:

* Errors in implementation of supposedly perfectly elastic or
* inelastic collisions Dangerous floating point equality comparisons
* Dead/logically unreachable code which may indicate a logic error


2. Correctness of the collision system - watch for:

* Unintended race conditions Ways a duplicate collision could be
* registered between the same two items twice on the same turn Access
* to current/live Ship stats via GetXyZ() methods off the Ship object
* when it should be using cached or snapshotted states Systemic biases
* that predictably favor one team over the other

3. General errors like: Sign errors, inequality wrong direction
errors, extensive computations whose values are never used, etc.

After we identify and fix crucial bugs I'll ask you for help
rearchitecting and simplifying the code for improved elegance - but
for now leave architectural or design issues for later and focus on
bugs/errors that will lead to bad gameplay results.

Please report a list of detected issues, and for each issue include a
brief summary of the problem, the relevant line numbers / triggering
conditions, etc.. Each issue you flag will become an issue for a
developer to fix so include the correct level of detail that a
developer could address it.

====

We're going to conduct a code review for a portion of a codebase that
simulates a simple 2d toroidal starship exploration and combat game
which is the basis for a coding contest.

I have attached the latest requirements / design docs in the docs.md
file, and updated project code in the .cpp files.

The code path we care about begins in:

Server's Simulation() method which iterates and calls World's
PhysicsModel()

PhysicsModel() in turn calls the Drift() method on each thing in the
world, and then resolves collisions via CollisionEvaluation()

Things in the word are polymorphic types derived from CThing and are
one of:

CAsteroids CShips CStations

Or generic things (GENTHING) which are used to implement short lived
laser beams.

The key point here is for this code review we are ONLY reviewing the
Server Side implementation of the game physics, collision handling
system, etc. to ensure it meets the specifications in the docs. We
needn't worry about client state or anything like that - we can treat
it as a black box.

The second key point is there is a default mode of operation, and a
LEGACY mode, enabled with various --legacy command line flags. This
review is ONLY of our default modes - consult the the default in
ArgumentParser.C - IGNORE AND DO NOT REVIEW ANY CODE PATHS NOT ACTIVE
BY DEFAULT.

Now review the system for architectural concerns:

* redundant / duplicative code that should be factored into its own
  module

* confused ownership semantics of state between interacting objects

* Areas where simplification could achieve the same result

* Overly complex methods which could be broken up at logical
  boundaries

* Readability and maintainability concerns

* Weird side effects / enforce the principle of least astonishment

====

Contest results:

Game 1-5 as team #2:
1: 80 | 120 | Win by ~93
2: 120 | 80 | Win by 160
3: 160 | 160 | Win by 120
4: 80 | 160 | Win by ~55
5: 160 | 97.777
(tie some vinyl destroyed)

Game 6-10 as team #1:
6: 120 | 120
7: 80 | 80
8: 120 | 120
9: 120 |93.333
10: 120 | 40

7-3 | 5-4-1

Game 1-10 (original vs new)
Original: 6
New     : 4

===

Wholly New Behaviors:

  * You can set the initial numbers and sizes of Uranium and Vinyl
    asteroids with: --uranium-num, --uranium-mass, --vinyl-num,
    --vinyl-mass (all asteroids of a material share the same initial
    mass). Note: These limits are constrained by the world's maximum
    items capacity which in turn will place an upper bound of around
    472 total asteroid items that could theoretically exist at
    once. The original values (5 asteroids of 40 tons each) are the
    defaults.

  * You can use the NormalizeCentered and NormalizeEdges methods to
  coordinate utilities which will bias equivalent distance
  calculations to head through the center of the map, or the edges of
  the map, respectively. This is needed because hips starting in some
  stations will tend to find paths to enemy stations through the
  center of the map, and some through the edge of the map, which is
  not a tactically symmetric situation. Without using this function
  some nagivation logic will end up tending more towards the center or
  more towards the edges which are not tactically symmetric.

  * The game can play soundtracks and effect sounds, and comes with an
    asset pack of Star Control II sounds and some configured for ship
    events. Start the observer with --mute to disable.

  * The game can include custom ship art, and comes with asset packs
    of Star Control II ships which are randomly applied for each
    match, or can be overriden with the --ship-art to the team
    binary. Use --ship-art mm4orange and --ship-art mm4blue for the
    original colors (the first team to connect should use mm4orange
    and the second mm4blue).

Major old behaviors changed:

These can all be reverted at once with the --legacy flag.

Re-enabled with --legacy-velocity-limits:

  * 5x costing error for Ship Thrust orders than documented (although
    there is a suspicious 1/6th cost factor in allocating thrust, so
    maybe the end result was what was desired and it combined the
    costing error with a discount elsewhere).

  * Velocity Clamping Error - The velocity clamping approach did
    asymmetrical things depending on the exact headings and thrust -
    and could even accelerate ships above the limit! Now velocity is
    clamped to 30 by: a. Compute the total velocity vector given by
    current_v + thrust b. Truncate the vector to the region inside our
    "velocity circle" whose radius is the game world's max speed.
    b. Charge an additional fuel penalty equal to the amount of thrust
    this truncation effectively gives to the ship "for free."

  * Station Departure Thrust - The original engine granted free thrust
    to departing ships only on the first 0.2 second sub-tick - once
    that time elapsed the ships were no longer docked, and hence
    thrust was no longer free. However since the only interface to
    players is the SetOrders method and that acts in 1 second
    increments, now all thrust for the entire duration of the O_THRUST
    order when departing a station is free of fuel costs.

  * Double spend bug with Shields and Thrust, or Shields and Turn -
    The game engine allows you to submit more orders than you have
    fuel for - only each individual order is clamped to current
    fuel. This is fine and in fact you may acquire fuel during turn
    sub-processing so it's OK to do this. However, there were errors
    in the legacy code where fuel availability checks were made, but
    then original requested thrust or turn amounts were used anyway.

  * Low fuel underturn/underthrust - The original implementation
    required ships to have enough fuel for their entire turn/thrust
    order at each sub-tick in the game, which caused these orders to be
    artificially clamped in very low fuel conditions.

Re-enabled with --legacy-asteroid-destruction:

  * Asteroids which collide with ships, and which are too large for
    the ship to pick up, but who are too small to be subdivided into 3
    equal size asteroids instead just bounce off the ship in an ideal
    elastic collision (previously these asteroids were destroyed
    utterly by such collisions).

Re-enabled with --legacy-asteroid-eat-damage:

  * Eatable Asteroid Collision Handling - The original simulation
    dealt damage to the ship when colliding with an asteroid
    regardless of whether the asteroid was "eaten" by the ship. Now
    the default behavior is eaten asteroids deal no damage to the
    ship.

Re-enabled with --legacy-cargo-calc:

  * Today we allow small floating point errors when deciding if an
    asteroid fits within a ships cargo. Historically exact comparisons
    of the form (cargo_capacity - current_carg) >= asteroid_mass were
    checked, which would cause problems for cargo sizes that were
    trying to be exact multiples of common asteroid sizes (e.g. 40/3).

Re-enabled with --legacy-collision-detection:

  * Collision Detection - Proper minimal time to intercept
    calculations. Previously the collision detection for A and B
    projected their relative velocity out from A a distance equal to
    their separation, and saw if that point was a collision. This
    approach is was not robust and would miss glancing collisions from
    oblique angles.

  * Collision Handling - The legacy system had many race conditions
    and other odd behaviors in it's collision handling system, and
    also processed collisions in a certain order that caused systemic
    biases (e.g. station collisions happened first in scenarios where
    multiple collisions were possible, the first team's collisions
    happened first in scenarios where multiple team objects were
    involved in collisions). You can read about some of the details in
    docs/LEGACY_COLLISION_ENGINE.md. We have a new collision handling
    system which:
    
     a. Fixes various bugs / unintended behaviors - including many
     instances of "double hits" where a collision would be registered
     twice or more, effectively making them more damaging than
     documented.

     b. Resolves collisions in ascending order of overlap which
     attempts to monitor which collisions would have happened first,
     and eliminates many systemic biases. (e.g. if a ship and a
     station overlay by 5, and a ship and an small asteroid overlap by
     2, the ship docks first and then the asteroid collision ends up
     not happening because you can't collide with docked things. Note
     that in this scenario the distance between the ship and the
     station is still 30+12-5=37 which is much more than the distance
     between the asteroid and the ship - however we take the greater
     overlap to indicate the ship would have hit the station first.)

     c. In the cases where overlap is equal, we process the collisions
     in a random order to eliminate systemic bias.

     d. We do lots of clean up logic once a collision happens to
     prevent nonsensical results (e.g. once an asteroid has collided
     with a ship and been eaten, re remove that asteroid from any
     future collision analysis this turn).

Re-enabled with --legacy-docking:

  * Failed Launches - The existing code remembered the separation
    distance between a ship and a station at the time it docked, and
    then added 5 to this number on undocking (with an initial distance
    of 0). This caused - especially in the initial game turns - a
    behavior of ships launching, and being immediately redocked, and
    then having to launch again as the docking distance is "walked
    out" in steps of 5 until it exceeds 42. The new behavior just
    always places launching ships a distance of: StationSize +
    ShipSize + ShipSize/2 away (the last ShipSize/2 is to give a
    safety margin.

Re-enabled with --legacy-facing-detection:

  * The legacy CThing IsFacing() method had a subtle bug which would
  return false when either of the two things were on the closed
  interval world boundary and the other was on the same X or Y
  dimension as them and 512 units away. In this case there are two
  valid intercept directions: d and d+pi which both have minimum
  length 512 distance paths - however old IsFacing would say false
  on one of those paths. We took care of that.

Re-enabled with --legacy-laser-exploit:

  * Laser Power Determined Exclusively by Order Magnitude - This
    presented a mundane fuel tracking error where a laser order would
    always operate on the requested order amount, not on available
    fuel, and since shields and some portion of turn and thrust orders
    are processed before lasers this could generate slight errors in
    low fuel conditions. However, it also presented the opportunity
    for a substantial exploit where a clever attacker could make a
    derived class from Ship and use it to set arbitrarily large laser
    orders and one shot anything. This is demonstrated in the
    jameskirk/ team, and can only be seen when the exploit is enabled
    via the flag.

Re-enabled with --legacy-rangecheck-bug:

  * Weird Test Leads to Failed Laser Hits Depending on Floating Point
    Errors - We're not 100% sure why this test was originally
    inserted, but we suspect it was intended as a range check. However
    what the comparison actually does is compute the beam length two
    different ways, and then check of beam_computed_way_1 >
    beam_computed_way_2. Ideally this would never be true - however
    due to floating point errors it can be. When it is true otherwise
    valid laser targets are missed.
    
Re-enabled with --legacy-physics:

  * Non-conservation of momentum on jettison - When jettisoning
    asteroids the simulation "fires" them out the front of the ship at
    the ships current velocity - however it registered a momentum
    kickback of twice the jettisoned asteroid. We conserve momentum by
    default now.

  * Non-conservation of momentum on various collision types -
    Asteroid-Laser, Asteroid-Ship, Laser-Ship, and Ship-Ship
    collisions used to use various different physics for collisions
    now: All laser collisions are perfectly inelastic collisions, and
    Asteroid-Ship and Ship-Ship collisions are perfectly
    elastic. (Station interactions are unchanged and for asteroids
    correctly model collisions with "infinite" masses.

  * Rotation angle clamping - The original game engine allowed any
    value to the SetOrder for turns, and would charge fuel even though
    for example turns of: pi/4 and 200*pi + pi/4 both leave the ship
    with the same orientation. Now we normalize the input requested
    turn to [-pi,pi].

  * Rotational fuel costs - The legacy engine had a rotational cost
    which scaled linearly with the angle turned. Now we treat the ship
    as a disk of uniform density equal to its current mass, and model
    the turn as being achieved by constant acceleration, and then
    constant deceleration, to change the orientation by the desired
    amount in the requested time period with no ending angular
    velocity.

Re-enabeld with --legacy-ship-destruction:

  * Ships now drop uranium and vinyl asteroids equal to the amount of
    fuel and cargo they were carrying at time of destruction, if those
    quantities exceed the minimum world object mass.

Not re-enableable:

  * Create Vinyl With Jettison Bug - you could jettison any amount of
    Vinyl as the bounds check to not jettison more than you had an
    incorrect inequality.

  * Jettison Order While Docked Bug - the game engine prevents you
    from Jettisoning cargo while docked, but allowed you to
    SetJettisonOrder, and would report incorrectly with GetJettison
    that the order would do something (it would also clear O_TURN and
    O_THRUST orders as a side effect). Now SetJettisonOrder will do
    nothing if you are docked.

==================================

========================== ENGINE TODO ================================

* Game option to prevent docking at enemy bases (set at start time of
  either the server or observer) (counts as collision with asteroid
  for damage?)

####################### END ENGINE TODO #############################

========================== Groonew TODO =============================

SHOOT BETTER - WE ROTATE AND NEVER SHOOT - NO COLLISION - MAYBE
EFFICIENCY CHECK????

===

---
2.2. Medium: Inconsistent Fuel Reserve Logic Across Modules
File: GroonewCombined.cpp (L477), GetVinylCombined.cpp (L386)

Summary: The team intends to use a dynamic fuel reserve strategy (5.0 normally, 0.0 late game, calculated in BuildViolenceContext). However, the strategic planning (DetermineShipWants) and tactical shield maintenance (GetVinyl::Decide) ignore this dynamic calculation and use a hardcoded constant (groonew::constants::FUEL_RESERVE).

Impact: Late in the game, when the dynamic reserve should be zero, ships might still try to acquire fuel or preserve the hardcoded reserve instead of committing resources to combat or shields, contradicting the intended strategy.
--

Tight packing fuel: in endgame conditions when we're not boosting
emergency shields and about to collide with a uranium asteroid,
instead eject if that would help us fit the thing (and not turning /
thrusting otherwise, can't eject less than 3.0).

Add fun announcer quotes - commence primary ignition, let's blow this
thing and go home, Asteroids to not concern the empire, etc.

After reducing enemy base to 0 and killing all enemy ships do a little
acrobatic maneuvers.

FOR EVOAI - Give it groogroo as a base, and then have the evoai
compete against groonew? Once Groonew is consistently beating groogroo!

TOROIDTOROIDTOROID
0. I definitely need to consider toroidal approaches in perfect
navigation - getting shortest distance doesn't give shortest time to
intercept - ESPECIALLY with a max speed.
Consider the 1d case where ships are conceptually on a circle of
circumference L:

Dshort <= L/2
Dlong >= L/2
Best time to intercept short = Dshort / (maxspeed - vtarget)
Best time to intercept long = Dlong / (maxspeed - vtarget)

Ignoring some unit confusion above with speed and velocity, the basic
idea is its very easy for the best time to intercept being along the
long path, if the target is moving away from you at close to maxspeed
- even if you pay a 1 turn penalty for turning around and drifting.

TODO: Formally solve this / come up with a formula / logic to pick
direction.
TOROIDTOROIDTOROID

Minor fix: * The 5 1/5th turns thing is going to cause some trouble
too but that should be a fine detail and our gross 1 turn planning
should hold up well-ish.

**************** GROONEW PERFECT NAV ************************************

* See extensive todos and "Steps" in the documentation of determine
  order in Groonew.C and GetVinyl.C for team Groonew.

Consider if a better build out for team groonew involves a hunter ship
with 60 fuel who tries to shoot enemy ships in the early game and base
late game.

* Perfect navigation in Groogroo/MattMatt:
  * Phase 2 - fixes related to 0.2 micro tics between game turns.

* Deep thoughts for future perfect navigation:
  1. Our current approach assumes if you can't reach destination D with
  one rotation and one thrust in T turns you can't reach it at all in
  T turns.
      * This turns out to be false, there are plenty of times when
      thrust-turn-thrust and maybe other approaches are better (even
      leaving aside the stuff that happens with thrust governing
      giving us the ability "turn" in the sense we rotate our velocity
      vector in a somewhat controlled manner without issuing the TURN
      order.
  1. DEEP THINK ON OPTIMAL PATHING IN 2D:
     https://docs.google.com/document/d/1_AvkE_JgxQ920-TOI9HCcrU0C_781qOoa-mtjaHXHnM/edit?tab=t.0

* Improve Collision handling:

  * Note - we did briefly implement and back out path canceling when
    we detect us and/or the target will have collisions before our
    intercept time beyond what is in the code today - this hurt our
    performance empirically - it turns out aggressively flying towards
    the target is a better strategy than waiting for a collision free
    path.

  * We detect the first collision with us, but don't check if that
  thing itself collides with anything _else_before then.

  * If we do this, it will probably fall under the experimental combat
    handling idea to check for interposed things between us and our
    shots - e.g. actually model the entire game world ticks out and
    see what's what: note that asteroid "collisions" might occur and
    just be no-ops with other asteroids.

**************** END GROONEW PERFECT NAV ************************************

1. For Codex branch, check if Team Ares is using toroidal logic,
suggest it to use the relevant thing/ship primitives which do that
correctly.

------------------- SYSTEM NOTES -----------------------------------------

What is the inheritance hierarchy for our project:

Asteroid, Laser, Ship, Station IS A Thing

CTeam HAS A:
  * CWorld (pmyWorld)
  * CBrain (pBrain)
  * Array of CShips (apShips)
  * CStation (pStation)

Player teams IS A CTeam

Thing is base class for Asteroid, Ship, Station, and Laser

CShips have:
  * Ship physics:
    * A ships mass is 40 + its fuel + its vinyl
  * Costs and limits (other than default fuel limits)
    * Shield increase 1:1 with fuel spent
    * Lasers cost the value to be fired / 50
    * Thrusting costs the magnitude of the new velocity after the acceleration is applied * current ship mass (see above) / 6*maxspeed*empty_ship_mass = 6*30*40 = 7200. (New velocity vector limited by maxspeed)
      * Thrusting out of a docked position is free, however may be gated based off max fuel size
    * Turning costs the O_TURN provided |value| * ship mass / 12*PI*empty ship mass = 480*Pi - turning SETS THE SHIPS ROTATION TO THE O_TURN AMOUNT IN RADIANS PER SECOND.
    * Jettison costs nothing for vinyl, and the amount jettisoned for fuel.
  * Members: myNum, bDockFlag, dDockDist, dLaserDist, pBrain, arrays of: adOrders, adStatCur, atStatMax
  * Methods (among others like establish capacities):
    * Drift - handles order processing on the ships turn:
      * 1st Jettisons stuff, if any
      * 2nd updates shields, if any
      * Then turns, if any
      * Then thrusts, if any
      * Then updates position
    * AsteroidFits
    * LaserTarget (Purportedly what laser beam will hit if fired) - does so only if the ship is facing along the shortest straight line path - which is not a catastrophe given our 512 length max laser, but is inconsistent in that it will report targets that can't be reached (due to short requested laser length or fuel constraints) on the shortest path as we face, but not any (definitionally unreachable due to max beam length) targets on the longer paths that we face.
      * This logic may in fact be the reason for the 512 max beam length (also a 1024 or larger beam will hit yourself if it hits nothing else)
    * GetLaserBeamDistance (purportedly the distance the beam will traverse)
    * AngleToIntercept - Seems to correctly compute the angle we need to turn to _FACE_ another target next turn taking both our velocities into account, and assuming they stay the same - but this will not do correct vector math I think.
    * AstToStat
    * StatToAst
    * Reset/Get/Set Orders, and special SetJettison/GetJettison
    * HandleCoollision
    * HandleJettison
  
CThings have:
  * Members kind, mass, size, orient, velocity, team, alive, image, name, worldindex, world.
  * Methods:
    * Drift
    * Collide
    * Overlaps
    * GetMomentum (return velocity*mass)
    * DetectCollisionCourse <- fundamentally broken, I changed it (it was using flyby logic which wasn't figuring the closest point of approach - it was more or less estimating if these things would collide if 
    * PredictPosition <- only predicts position, not how we'll be facing
    * RelativeVelocity <- other.velocity - our.velocity
    * RelativeMomentum <- RelativeVelocity * other.mass
    * IsFacing <- True if overlap (buggy due to FP stuff), otherwise establishes a coordinate system with our ship at the origin, and then draws a line on our facing out to DistTo(Other) distance and sees if that point is within the radius of the other object.
    * HandleCollision (virtual)

Physics Engine:

The server's game loop:
while (time < 300.0) { Simulation(); BroadcastWorld(); ReceiveTeamOrders(); }

The team client's game loop:
while (connected) { ReceivedWorld(); DoTurn(); }
  * the Client's DoTurn() gets data
    * calls Team::Reset()
      * The Team::Reset() method calls ResetOrder() on each ship.
    * calls Team::Turn()
      * This method does nothing by default, teams provide their own
        implementation.
    * then sends info back to the server.

SO WE DO ALL OF THIS:
The server's Simulation() does:
  1. The world's PhysicsModel() with a small tstep (0.2) 5 times.
  2. After the 5th call, when 1 second has elapsed, it calls the world's LaserModel() which handles laser collision, adding new and killing dead things.

At each step the PhysicsModel does:
  1. For each thing their Drift(dt) method which is 0.2 in our example
  2. CollisionEvaluation()
  3. AddNewThings()
  4. KillDeadThings()

In the Drift step above:
  1. CShip::Drift:
     * clamps to maxspeed
     * Does orders in this sequence: Jettison, Shields, Turn, Thrust (which in turn will change Vel if a thrust occurs, and change omega of a turn occurs)
     * Changes position and orientation by Vel*dt and omega*dt
     * Sets omega and dLaserDist to zero
  2. Asteroids just do the default CThing behavior of move/rotate dt.
== THEN WE GET NEW ORDERS AND REPEAT ===

Coordinates:

CTraj has a rho (magnitude) and theta (direction):
  * Can ConvertToCort and be created FromCord:
    * Convert to cord makes x = rho*cos(theta) and y follows sin - so "convert to cord" gives you the coordinate this vector points to from the origin.
    * FromCoord also assumes the coordinates are relative to the origin and computes the vector.
  * Normalize() - Keeps -PI < theta < PI and rho  > 0
Notes:
  * Defines const doubles for PI and PI2.

CCord has an x and a y position, and methods:
  * cc.DistTo( occ ) Shortest distance taking toroidal geometry into account
  * cc.AngleTo( occ ) Proper heading for shortest distance taking toroidal geometry into account
  * cc.VectTo( occ ) returns a CTraj object with a vector to the other point
  * cc.Normalize() for putting coordinates into the game field
Notes:
  * Coord.h defines the playing field boundary as -512 to 512 with const doubles fW[X|Y][Max|Min]

=== SERVER / CLIENT LOGIC ===

  Client-Server Architecture

  1. Team Binary Compilation: Each team (like ChromeFunk) is compiled into the mm4team binary. The key is that
   CTeam::CreateTeam() in ChromeFunk.C:10 returns a ChromeFunk instance, linking the team's AI logic into the
  binary.
  2. World State Management:
    - Server maintains authoritative world state (all ships, asteroids, stations)
    - Client receives complete world snapshots via ReceiveWorld() which calls pmyWorld->SerialUnpack()
  (Client.C:166)
    - The initial world creation in Client.C constructor is just placeholder - immediately replaced when
  MeetWorld() connects to server
  3. Game Loop Flow:
  Client (mm4team.C:28-29):
  1. ReceiveWorld() - Get full world state from server
  2. DoTurn() - Execute team AI and send orders back
  4. Team Logic Execution (Client.C:204-217):
    - DoTurn() calls pTm->Turn() which executes ChromeFunk's strategic AI
    - ChromeFunk::Turn() iterates through ships calling pSh->GetBrain()->Decide()
    - Each brain's Decide() sets ship orders (thrust, turn, fire, etc.)
    - Orders are packed via SerialPack() and sent to server
  5. State Synchronization:
    - From Server: Full world state including all ship positions/velocities/cargo/shields
    - To Server: Only ship orders (thrust amount, turn amount, fire commands)
    - Server simulates physics and combat, then broadcasts updated world state

  The team AI (ChromeFunk) never directly modifies world state - it only reads state and generates orders. The
   server is authoritative for all physics and game state changes.

  One Time Team Initialization Protocol

  When a team client connects (Client.C:129-135), it:

  1. Calls Init() - Team sets names and capacities (ChromeFunk.C:36-56):
    - Team name: "Chrome Funkadelic"
    - Station name: "HeartLand"
    - Ship names: "SS TurnTable", "Bell Bottoms", etc.
    - Ship capacities: 45.0 fuel, 15.0 cargo
  2. Packs initialization data via SerPackInitData() (Team.C:243-272) which sends:
    - Team number
    - Team name
    - Station name
    - For each ship:
        - Cargo capacity
      - Fuel capacity
      - Ship name
  3. Server receives and unpacks this data using SerUnpackInitData() (Team.C:274-307), which:
    - Sets all the names on server-side objects
    - Configures ship capacities
    - Initializes fuel to max capacity and shields to 15.0

  This is a one-time handshake during connection. After this, the server knows all team/ship/station names and
   ship capacities, allowing it to:
  - Enforce cargo limits during pickup operations
  - Track fuel consumption based on configured capacity
  - Display correct names in observer views
  - Manage team-specific station operations

  The team binary configures these values in Init(), but they're immediately transmitted to and stored by the
  server, which becomes the authoritative source for all game mechanics involving these properties.

==== ChromeFunk Brain Approach ====

The CBrain hierarchy in ChromeFunk demonstrates a context-switching AI pattern using
  temporary brain replacements. Here's the design:

  Brain Hierarchy

  CBrain (base class)
  ├── Voyager    - Station departure specialist (temporary)
  ├── Stalker    - Navigation/interception
  ├── Shooter    - Combat (inherits from Stalker)
  └── Gatherer   - Resource collection (inherits from Shooter)

  The Brain-Swapping Pattern

  The key insight is in Voyager (lines 43-54, 56-81):

  1. Temporary replacement: Voyager stores the previous brain (pLastBrain) and installs itself
  2. Self-deletion: Once undocked, Voyager deletes itself, automatically restoring the previous
   brain via its destructor
  3. Example flow: Gatherer → Voyager → Gatherer

  This happens in Gatherer::Decide() at line 343:
  if (pShip->IsDocked()) {
      new Voyager(this);  // Creates Voyager, which replaces Gatherer temporarily
      return;             // Voyager handles departure, then restores Gatherer
  }

  Requirements That Led to This Design

  This implementation suggests these requirements:

  1. Specialized behaviors: Different tasks need completely different decision logic (docking
  vs combat vs gathering)
  2. State preservation: Ships need to return to their previous behavior after temporary tasks
  3. Clean transitions: No complex state machines or if/else chains cluttering the main logic
  4. Reusable components: Shooter extends Stalker, Gatherer extends Shooter - building
  complexity through inheritance
  5. Self-managing contexts: Behaviors know when they're done and clean up after themselves

  The pattern allows ships to have a "stack" of behaviors - push a temporary brain for special
  situations (like undocking), then pop back to the previous behavior automatically. It's
  elegant for handling context switches without losing the ship's primary mission.

===============

Dubins' Result: The shortest path between any two positions+orientations is one of only 6 types:

LSL, RSR, LSR, RSL, RLR, LRL

Advanced: Reeds-Shepp Vehicle
Like Dubins but can reverse:

Adds backward segments
48 types of optimal paths instead of 6
Used for parking, tight maneuvering

==============

------------------------------- END NOTES ----------------------------------------------------

QAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQA

Q. Can you cheat by setting things like ship velocity, asteroid size,
base vinyl, etc.?
A. You can set these things, but your team is running in a client
which gets a private version of the world each tick from the
server. The server receives your orders and processes physics based on
them, and resends the updated world, so you can't cheat this way.

Q. Can you cheat by manipulating the raw orders set rather than using
SetOrder?
A. Yes, with limited success: you can create a derived class of CShip
that has no private data members (and hence the same memory layout as
CShip) with members that cast a CShip via C style casting or
reinterpret cast to be your derived class and return pointers to the
undostats and order arrays for direct manipulation, however:
  * adStat values are ignored by the server from the client's data
  * adOrders are processed - so you can do things like set multiple
    orders or set magnitudes you wouldn't have been allowed to, but
    the server then replays most of orders through the Ship.C's
    SetOrders which enforces the rules. It is possible you could
    trigger a corner case here, but the design of SetOrders is
    intended to be robust against this.
  * However, the legacy engine implementation of LaserModel does allow
    an exploit here - it powers the laser with whatever has been set
    in the order, and fires it with that amount, and only later does
    it deduct fuel.

Q. Can you cheat by issuing multiple commands whose combined fuel cost
exceeds available fuel but still get their benefits?

A. Generally no - but there is again a special case with the Laser
implementation. The legacy engine will effectively do this:
1. Raise shields by full requested amount, deducting the fuel required.
2. Do the first subtick (0.2) seconds of Thrust or Turn if one is specified, deducting the fuel required.
3. Shoot lasers based on the input command value, then figure fuel.
4. Do the remaining sub-ticks of Thrust/Turn.
In step 3 you can exceed your fuel allotment - especially if you raised
shields. Lasers are effectively "free" on any turn where you'd run out
of fuel before the 2nd physics tick anyway.

================== END Q&A ===========================================


ZZZZZZZZZZZZZZZZZZZZ DAMAGE NOTES ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

Ship, Asteroid, and Station Damage Overview:

* Ships take damage to shields from collisions with Asteroids, other
  Ships, and lasers. If the damage ever exceeds shields remaining the
  ship is destroyed. Ships dock when they "collide" with stations
  taking no damage. Ships take no damage from other collisions or
  lasers while docked.

* Asteroids take damage from collisions with Ships and
  Lasers. Collisions automatically shatter asteroids into 3 equal size
  pieces, or destroy them if doing so would make the fragments smaller
  than 3.0 Tons. Asteroids bounce off of stations and don't collide
  with one another (e.g. can overlap one another on the map).

* Stations take damage from lasers only. Laser damage depletes vinyl
  stores on the station down to a minim of zero.

Order Sequencing:
* Once each team has submitted orders to the server the following occurs:
  1. Shield raising orders are processed first.
  2. Then Thrust, Turn, Drifting and resulting collisions in one
  sub-step of 1/5th of a full turn duration.
  3. Then laser shots are processed in full, including damage being dealt.
  4. Then Thrust, Turn, Drifting and resulting collisions in four
  steps of 1/5th of a full turn duration.

Ship Non-Laser Collision Damage Calculations:

* When a ship collides with an asteroid or another ship, it takes
  shield damage equal to: (the mass of the object collided with)*(the
  magnitude of the relative velocity of the colliding objects) / 1000.

Ship Collision Notes:

* Damage depends only on the mass of the object collided with - not
  the mass of the ship which collides
* The maximum theoretical combined velocity of two colliding objects
  is 60
* Ships weigh 40 tons + their current fuel + their current vinyl cargo
  which means they lie in the range of 40-100 tons.
* Asteroids weigh between 3 and 40 tons. (Theoretically asteroids of
  up to 60 tons could exist if a ship with 60 tons of cargo collected
  60 tons worth of asteroids and jettisoned them, but we ignore these
  corner cases).

Therefore the maximum damage from a single collision to shields is:
  (60*100)/1000 = 6 for a ship to ship collision
  (60*40)/1000 = 2.4 for a ship to asteroid collision
  
Note: Due to engine behaviors that temporarily allow for excess speed
during the simulation, the theoretical Ship-Ship damage is closer to
8.4 but this would only happen in exceptional cases, and this behavior
may be changed.


Ship Laser Damage Calculations:

When a ship fires a laser it specifies a beam length of up to 512 (max
beam length = min(world_width/2, world_height/2)).

The fuel cost to fire a laser is beam length / 50.

When a beam strikes a target it is treated as a collision with an
object of mass: 30*(beam length - distance from firing ship to target)

Ship Laser Notes:

* Ships have a radius of 12, so when two ships shoot at one another
  they are always at least 24 units apart.

* For a "point blank" laser shot of beam length L:
  * The shooter spends L/50 fuel on the laser
  * The target loses (30*(L-24))/1000 shields. Note further that 1
  unit of shield costs 1 unit of fuel.

So for a point blank laser shot the shooter expends Fs fuel to
deplete: 30*(Fs*50-24)/1000 = St of the target's shields.
* So in terms of Fs, the target's shield loss is (24+1000*St/30)/50 =
  24/50 + 2*St/3.
* In other words, for each unit of fuel the shooter spends at point
  blank the target would have to spend around 1.5 units of fuel to
  prevent that much damage with their shields

The "break even" distance Db at which a shooter's fuel cost to damage
shields is equal to the targets cost to raise their shields is:
  * Fs = L/50 = St = (30*(L-Db))/1000 is when Db = L/3, or put another way:
  * When the target is closer than 1/3rd of the beam length shooting
    is more cost effective than shields, and beyond that less cost
    effective.

Shooting is 2x more costly than shields at Db = 2L/3, and then
degrades rapidly (3x more costly at 7L/9, 10x more costly at 14L/15).

The maximum damage from a single laser blast at point blank range of a
maximum power laser is: 30*(512-24)/1000 = 14.64.

Asteroid Laser Damage Calculations:

These are similar to ship to ship calculations where:
* Any single shot that deals >= 1 unit of Shield damage shatters an asteroid
* Any single shot that deals < 1 unit of Shield damage has no effect
  (cumulative small damage have no effect - it does not accumulate
  like a ship).

Station Laser Damage Calculations:

These are similar to ship to ship calculations where:
* A shot that would deal X units of Shield damage depletes the vinyl
  stores of the Station by X, to a minimum of 0.

ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

========================== GAME PHYSICS AND CONSTANTS QUICK REFERENCE ====================

Asteroid radius: 3+1.6*sqrt(mass)
Ship radius: 12
Station radius:

Maxspeed = 30
Game world is 2-D toroid with x, y are in [-512,512)
Items have an orientation, which is in [-PI, PI) with 0 to the right / eastward.

Asteroid mass:
 * >= minmass = 3.0
 * Typically either 40 (our games creation size), or 40/3 (after first break) or 40/9 (after second break). Other sizes are possible due to ships jettisoning different amounts

Ship mass:
 * Empty mass = 40
 * Total mass = 40 + fuel tons on board + vinyl tons on board

Items take damage by colliding with masses:
Ships colliding with laser: Remaining laser mass / 1000 damage
Ships colliding with ship or asteroid: Magnitude of relative velocity between ship and the other thing * mass of the other thing / 1000

Lasers are modeled as colliding masses for damage purposes.
  * Max beam length: 512
  * Beam fuel cost: 1 ton of fuel per 50 units of length
  * Beam collision mass: 30 * (L - D) where L is the total beam length, and D is the distance along the beam before collision
    * (internally this is handled by replacing beam strikes with temporary beam objects that originate 1 unit away from the center of the target along the mean line)

################# END GAME PHYSICS AND CONSTANTS QUICK REFERENCE ######################

