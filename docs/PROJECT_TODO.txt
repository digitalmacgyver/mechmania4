# This is a scratchpad of everything I'm considering for this
# project. Please ignore.

===

Ship, Asteroid, and Station Damage Overview:

* Ships take damage to shields from collisions with Asteroids, other
  Ships, and lasers. If the damage ever exceeds shields remaining the
  ship is destroyed. Ships dock when they "collide" with stations
  taking no damage. Ships take no damage from other collisions or
  lasers while docked.

* Asteroids take damage from collisions with Ships and
  Lasers. Collisions automatically shatter asteroids into 3 equal size
  pieces, or destroy them if doing so would make the fragments smaller
  than 3.0 Tons. Asteroids bounce off of stations and don't collide
  with one another (e.g. can overlap one another on the map).

* Stations take damage from lasers only. Laser damage depletes vinyl
  stores on the station down to a minim of zero.

Order Sequencing:
* Once each team has submitted orders to the server the following occurs:
  1. Shield raising orders are processed first.
  2. Then Thurst, Turn, Drifting and resulting collisions in one
  sub-step of 1/5th of a full turn duration.
  3. Then laser shots are processed in full, including damage being dealt.
  4. Then Thrust, Turn, Drifting and resulting collisions in four
  steps of 1/5th of a full turn duration.

Ship Non-Laser Collision Damage Calculations:

* When a ship collides with an asteroid or another ship, it takes
  shield damage equal to: (the mass of the object collided with)*(the
  magnitude of the relative velocity of the colliding objects) / 1000.

Ship Collision Notes:

* Damage depends only on the mass of the object collided with - not
  the mass of the ship which collides
* The maxiumum theoretical combined velocity of two colliding objects
  is 60
* Ships weigh 40 tons + their current fuel + their current vinyl cargo
  which means they lie in the range of 40-100 tons.
* Asteroids weigh between 3 and 40 tons. (Theoretically asteroids of
  up to 60 tons could exist if a ship with 60 tons of cargo collected
  60 tons worth of asteroids and jettisoned them, but we ignore these
  corner cases).

Therefore the maximum damage from a single collision to shields is:
  (60*100)/1000 = 6 for a ship to ship collision
  (60*40)/1000 = 2.4 for a ship to asteroid collision
  
Note: Due to engine behaviors that temporarily allow for excess speed
during the simulation, the theoretical Ship-Ship damage is closer to
8.4 but this would only happen in exceptional cases, and this behavior
may be changed.


Ship Laser Damage Calculations:

When a ship fires a laser it specifies a beam length of up to 512 (max
beam length = min(world_width/2, world_height/2)).

The fuel cost to fire a laser is beam length / 50.

When a beam strikes a target it is treated as a collision with an
object of mass: 30*(beam length - distance from firing ship to target)

Ship Laser Notes:

* Ships have a radius of 12, so when two ships shoot at one another
  they are always at least 24 units apart.

* For a "point blank" laser shot of beam length L:
  * The shooter spends L/50 fuel on the laser
  * The target loses (30*(L-24))/1000 shields. Note further that 1
  unit of shield costs 1 unit of fuel.

So for a point blank laser shot the shooter expends Fs fuel to
deplete: 30*(Fs*50-24)/1000 = St of the target's shields.
* So in terms of Fs, the target's shield loss is (24+1000*St/30)/50 =
  24/50 + 2*St/3.
* In other words, for each unit of fuel the shooter spends at point
  blank the target would have to spend around 1.5 units of fuel to
  prevent that much damage with their shields

The "break even" distance Db at which a shooter's fuel cost to damage
shields is equal to the targets cost to raise their shields is:
  * Fs = L/50 = St = (30*(L-Db))/1000 is when Db = L/3, or put another way:
  * When the target is closer than 1/3rd of the beam length shooting
    is more cost effective than shields, and beyond that less cost
    effective.

Shooting is 2x more costly than shields at Db = 2L/3, and then
degrades rapidly (3x more costly at 7L/9, 10x more costly at 14L/15).

The maximum damage from a single laser blast at point blank range of a
maximum power laser is: 30*(512-24)/1000 = 14.64.

Asteroid Laser Damage Calculations:

These are similar to ship to ship calculations where:
* Any single shot that deals >= 1 unit of Shield damage shatters an asteroid
* Any single shot that deals < 1 unit of Shield damage has no effect
  (cumulative small damage have no effect - it does not accumulate
  like a ship).

Station Laser Damage Calculations:

These are similar to ship to ship calculations where:
* A shot that would deal X units of Shield damage depletes the vinyl
  stores of the Station by X, to a minimum of 0.

==

3. Double check our base launch logic for turn 1 - make sure we get
the benefit of extra kicks and check if our logic properly handles
is_docked and fuel costs while docked.
  * See if we're pervasively crashing into one another on first launch
    - toy with approaches like turn 1: orient twards middle in fan,
    turn 2 max launch, turn 3+ normal control.
  
===

Contest results:

Game 1-5 as team #2:
1: 80  | 120 | Win by ~93
2: 120 | 80 | Win by 160
3: 160 | 160 | Win by 120
4: 80  | 160 | Win by ~55
5: 160 | 97.777 (tie some vinyl destroyed)

Game 6-10 as team #1:
6: 120 | 120
7: 80  | 80
8: 120 | 120
9: 120 | 93.333
10: 120 | 40

7-3 | 5-4-1

===

Major old behaviors changed:

These can all be reverted at once with the --legacy flag.

Re-enabled with --legacy-velocity-limits:

  * 5x costing error for Ship Thurst orders than documented (although
    there is a suspicious 1/6th cost factor in allocating thrust, so
    maybe the end result was what was desired and it combined the
    costing error with a discount elsehwere).

  * Velocity Clamping Error - The velocity clamping approach did
    asymetrical things depending on the exect headings and thrust -
    and could even accelerate ships above the limit! Now velocity is
    clamped to 30 by:
    a. Compute the total velocity vector given by current_v + thrust
    b. Truncate the vector to the region inside our "velocity circle"
       whose radius is the game world's max speed.
    b. Charge an additional fuel penalty equal to the amount of
       thrust this truncation effectively gives to the ship "for free."

  * Double spend bug with Shields and Thurst, or Shields and Turn -
    The game engine allows you to submit more orders than you have
    fuel for - only each individual order is clamped to current
    fuel. This is fine and in fact you may acquire fuel during turn
    sub-processing so it's OK to do this. However, there were errors
    in the legacy code where fuel availability checks were made, but
    then original requested thrust or turn amounts were used anyway.

  * Low fuel underturn/underthrust - The original implementation
    required ships to have enough fuel for their entire turn/thrust
    order at each subtick in the game, which caused these orders to be
    artificually clamped in very low fuel conditions.

Re-enabled with --legacy-asteroid-eat-damage:

  * Eatable Asteroid Collision Handling - The original simulation dealt
    damage to the ship when colliding with an asteroid regardless of
    whether the asteroid was "eaten" by the ship. Now the default
    behavior is eaten asteroids deal no damage to the ship.

Re-enabled with --legacy-collision-detection:

  * Collision Detection - Proper minimal time to intercept
    calculations. Previously the collision detection for A and B
    projected their relative velocity out from A a distance equal to
    their separation, and saw if that point was a collision. This
    approach is was not robust and would miss glancing collisions from
    oblique angles.

Re-enabled with --legacy-laser-exploit:

  * Laser Power Determined Exclusively by Order Magnitude - This
    presented a mundane fuel tracking error where a laser order would
    always operate on the requested order amount, not on available
    fuel, and since shields and some portion of turn and thrust orders
    are processed before lasers this could generate slight errors in
    low fuel conditions. However, it also presented the opportunity
    for a substantial exploit where a clever attacker could make a
    derived class from Ship and use it to set arbitrarily large laser
    orders and one shot anything. This is demonstrated in the
    jameskirk/ team, and can only be seen when the exploit is enabled
    via the flag.

Re-enabled with --legacy-physics:

  * Non-conservation of momentum on jettison - When jettisoning
    asteroids the simulation "fires" them out the front of the ship at
    the ships current velocity - however it registered a momentum
    kickback of twice the jettisoned asteroid. We conserve momentum by
    default now.

Not re-enableable:

  * Create Vinyl With Jettison Bug - you could jettison any amount of
    Vinyl as the bounds check to not jettison more than you had an
    incorrect inequality.

==================================

========================== GAME PHYSICS AND CONSTANTS QUICK REFERENCE ====================

Asteroid radius: 3+1.6*sqrt(mass)
Ship radius: 12
Station radius:

Maxspeed = 30
Game world is 2-D toroid with x, y are in [-512,512)
Items have an orientation, which is in [-PI, PI) with 0 to the right / eastward.

Asteroid mass:
 * >= minmass = 3.0
 * Typically either 40 (our games creation size), or 40/3 (after first break) or 40/9 (after second break). Other sizes are possible due to ships jettisoning different amounts

Ship mass:
 * Empty mass = 40
 * Total mass = 40 + fuel tons on board + vinyl tons on board

Items take damage by colliding with masses:
Ships colliding with laser: Remaining laser mass / 1000 damage
Ships colliding with ship or asteroid: Magnitude of relative velocity between ship and the other thing * mass of the other thing / 1000

Lasers are modeled as colliding masses for damage purposes.
  * Max beam length: 512
  * Beam fuel cost: 1 ton of fuel per 50 units of length
  * Beam collision mass: 30 * (L - D) where L is the total beam length, and D is the distance along the beam before collision
    * (internally this is handled by replacing beam strikes with temporary beam objects that originate 1 unit away from the center of the target along the mean line)

################# END GAME PHYSICS AND CONSTANTS QUICK REFERENCE ######################


========================== ENGINE TODO ============================================

TBD - Fix the laser exploit, but have a flag in it.

?!?!?! Concurrency / race double eating behaviors ?!?!?!??!

NOTE - THe current fix on our branch isn't really good / working - I
don't think it preserves the dual harvesting bug exactly for instance,
it just tries to add the claim mass to the ship, but in the old world
I bet even crazier things could happen like ship 1 breaks asteroid in
3 and ship 2 claims it - here if a ship claims 2 asteroids in one tick
it just gets tightly backed which probably isn't what happened in the
old engine.

BETTER IDEA: BUILD A LIST OF ALL COLLISIONS, THEN IN LEGACY MODE JUST
PROCESS THAT LIST IN THE SAME ORDER.

IN NEW MODE PROCESS THE LIST IN A SPECIAL (RANDOM?) ORDER AND/OR
FILTER FOR PROBLEMATIC STATES BEFORE RESOLVING!


Maybe my side-by-side idea here is a stupid one. Maybe instead I
should take a branched approach of:

team/src <- working code
team/legacy <- old code

And then build 2 binaries? but then teams can't run against either
probably if I change anything about an interface... and it loses the
per-feature switch.

For the collisions and similar things I might have to just make a
distinction in some cases about whehter the juice is worth the squeeze
or just fix bugs and say - hey - check out branch "total legacy 001"
if you want to play with _all_ legacy behaviors, and only preserve the
ones that make sense.

What makes sense to preserve:
 * NO Old collision detection? Nope - who wants broken collision detection (other than Chromefunk)
 * NO This buggy double claim unfair collision system? Nope.

* Velcoity clamping - maybe / yes - I could see people with old teams who want to compete but don't want different thrust semantics.

============= RACE CONDITION COLLISIONS / double yum=====================

A BIG CONCERN: Hang on - don't we have a bigger problem here? Isn't it possible thinking this through there are other such races, like what if a ship gets hit by 2 asteroids in one turn, does the engine correctly handle managing total cargo area in the ship under multiple collisions?

Or what if a ship collides with a base and a laser the same turn - nothing can hurt you while docked, how does the system determine which event happened first?

It almost seems like iteration with a stable order is causing a lot of problems, and we might want to move to an approach of detecting all collisions, building a list of them, randomizing the list (for fairness with regard to nonsystemic biases) and then processing the collisions one by one in order.

BUT ASTEROIDS ARE DEFINITELY BORKED ALLOWING DOUBLE CAPTURE.

Here's the exact sequence when Ship A and Ship B collide with the same asteroid:

Line 451: pTItr->Collide(pTTm, this) where pTItr = Asteroid, pTTm = Ship A

Asteroid's Collide() checks if they overlap (Thing.C:136)

If yes, calls HandleCollision() (Thing.C:147)

Asteroid's HandleCollision() sets:
  DeadFlag = true (Asteroid.C:151)
  pThEat = Ship A (Asteroid.C:157)

Line 452: pTTm->Collide(pTItr, this) where pTTm = Ship A, pTItr = Asteroid

Ship A's Collide() checks overlap, calls HandleCollision()

Ship A's HandleCollision() checks pThEat:
  pEat = asteroid->EatenBy() returns Ship A (Ship.C:697)
  if (pEat != NULL && !(*pEat == *this)) - pEat IS this ship, so guard passes!
  Ship A takes the cargo (Ship.C:716)

Next iteration of inner loop - Line 451: pTItr->Collide(pTTm, this) where pTTm = Ship B

Asteroid's Collide() checks overlap, calls HandleCollision()

BUG HERE: Asteroid's HandleCollision() OVERWRITES pThEat = Ship B (Asteroid.C:157)
  Even though asteroid is already dead!

Line 452: pTTm->Collide(pTItr, this) where pTTm = Ship B

Ship B's HandleCollision() checks pThEat:
  pEat = asteroid->EatenBy() now returns Ship B!
  Guard passes because pEat == Ship B
  Ship B ALSO takes the cargo!

The Root Cause:

The bug is in Asteroid.C:152-157:

if (OthKind == SHIP) {
    pThEat = pOthThing;  // ALWAYS overwrites, even if already eaten!
    if (((CShip*)pOthThing)->AsteroidFits(this)) {
        return;
    }
}

The asteroid ALWAYS updates pThEat to the current ship, even after it's been marked dead and already eaten by another ship!

Why The Guard Fails:

The pThEat guard in Ship.C is checking correctly, but by the time Ship B checks it, the asteroid has already overwritten pThEat to point to Ship B instead of Ship A!
================== double yum ===========================

Q. If station radius is 30, or in general if ship+station radius > x,
how does launching handle not immediately collidign / redocking?

Q. Double check that Coord DistTo and AngleTo produce proper toroidal
measures with some test cases and a hello_world style program that
just runs these functions.

Q. CTraj::Rotate noramlizes - does this reduce the cost? what if
someone wants to do a spinarooney and puts in a rotate of 1000*PI?

Engine enhancements:
  * Physically costed rotation based on assumption of linear accel and decel to change angle X and end up at a dead stop? (Normalized to physicall acceleration costs?)
  * Momentum handling on jettison
  * Review momentum handling on laser strike
  * Momentum handling on collision
  * asteroid mass correctly correlates with volume? Or I guess we're in 2d so area is OK?
  * Our ship collision logic deals damage to us based on our relative
    velocity with the thing we collide, and that things mass, our mass
    doesn't matter. Is this a "momentum swap" or normal physical /
    collision type? If not maybe adjust it.

* We do change momentum when capturing an asteroid, but this is OK -
  see if we conserve momentum or not - we should correctly conserve
  momentum. (This is a physics fix if we need to make one).

Ship.C HandleJettison : Conserve momentum in ship ejecting an asteroid
- as it is the asteroid leaves with our velocity, and we slow down
some (which doesn't conserve momentum), and als owe just place the
asteroid out a bit to avoid collisiono - that part is fine (Alghout
maybe it hsould be placed more 3+ship radius or something rather than
3!?!?

???????????? LASER TARGETING BUG ?????????????????????????
  Q. Is there a bug in LaserTarget?
     * We check if we are IsFacing, but we compare distance with DistTo which uses toroidal aware distance, and may not be the distance in the direction we're facing.
     * Also, the interface here seems confusing - if mindist > dlaspwr then we're not actually going to hit anything - we are just aiming at something too far away - so when that happens do we want to know that, or do we want to get that we're not aiming at anything.
  * AS PHRASED TO GTP-T HIGH: Is there a subtle bug in CShip::LaserTarget whereby both IsFacing and DistTo use toroid aware geometry, and so will report that a Ship is facing a target only if it is facing it along the shortest path to the target?
  E.g. if a ship is at (-400, 0) and is oriented with theta = 0 (facing rightward), and an asteroid is at (400, 0), won’t LaserTarget return false for that ship?

Now - it just so happens in our implementation that the maximum laser distance is 512 units, so in practice this might not matter much - however the logic for LaserTarget considers the case where a laser can’t reach the target and reports that yes, it is facing that target when it believes IsFacing is true - so at the least this seems inconsistent.
===END GTP-5 QUERY===

=== GTP ANSWER ===
Short answer: Yes, that subtlety is real.

What happens

- Toroid-shortest facing: CThing::IsFacing uses the shortest-wrap vector (CCoord::AngleTo/VectTo). So a ship at (-400, 0) facing θ=0
with a target at (400, 0) is deemed “not facing” (shortest vector is left, x = −224), and LaserTarget will ignore it. If the ship
faces θ=π, IsFacing returns true and the target can be selected.
- Range mismatch: CShip::LaserTarget picks the nearest facing target even if it’s out of range; it only clamps dLaserDist for UI. It
does not null the target when mindist > laser power.
- Flawed range check later: World::LaserModel then “validates” range using DistTo(ship, LasPos), but LasPos was constructed as ship +
(L, orient). DistTo there is the shortest toroidal distance and will be ≤ L by construction, so the range check almost never rejects.
If the true shortest distance to the target D > L, the code still proceeds and computes laser “mass” as 30*(L − D), which can be
negative.

Impact

- Your example (800 along the long way) is unreachable anyway because max laser length is clamped to 512, so ignoring it is
consistent with range. But the inconsistency remains: LaserTarget says “facing” based on shortest-path alignment, not on whether the
forward ray can reach the target; and out‑of‑range targets can slip through to LaserModel, producing negative laser mass.
- Side effect: Stations subtract cargo by mass/1000. A negative mass would increase station cargo. That’s a real bug path when
mindist > L but IsFacing is true.

Minimal fixes (pick one)

- Enforce range in target selection: In CShip::LaserTarget, skip targets with DistTo > current laser power (retain dLaserDist for
UI).
- Correct the range check: In CWorld::LaserModel, replace the DistTo(ship, LasPos) check with an along-ray test. Compute dir =
unit(GetOrient()); for candidate target center c (consider 9 toroidal images c + (iW, jH)), project r = (c − ship) onto dir: t =
dot(r, dir), d_perp = |cross(r, dir)|. Require 0 ≤ t ≤ L and d_perp ≤ target.size; pick the smallest t. If none hit, treat as out
of range.

If you’d like, I can patch LaserTarget to filter by range (simple, low risk), or implement the proper ray-cast (robust and consistent
with wrap-around).

Q8. Question 8: LaserTarget and Toroidal Geometry
Your interpretation is correct. CShip::LaserTarget relies on IsFacing, which uses CCoord subtraction to find the shortest path vector across the torus.
In your example (Ship at -400 facing East, Target at 400), the shortest path is West. IsFacing returns FALSE. The ship cannot target the "long way around."
This is consistent in practice because the laser range is capped at 512 units (half the world size).
Subtle Bug (The Antipode): There is an edge case bug when the target is exactly halfway across the world (distance 512). At this point, there are multiple equally valid shortest paths (e.g., East and West). CCoord normalization arbitrarily chooses one. If the ship is facing the target along one shortest path, but CCoord normalization chooses the opposite path, IsFacing will return FALSE, preventing the laser from firing despite correct alignment. 


????????????????? LASER BUG ???????????????????

Q. Verify undocking thrust and turn cost are not gated by fuel tank
size in engine (or document if they are).

Q. The undocking logic wiht dDockDist seems a big mess - both the bad
Cursor AI and Codex say it has something to do with recording the
center to center distance from prior docking and sending the ship out
on that trajectory or something (maybe so ships can dock -> launch
without taking a game turn to rotate and if so they head out the way
they came in? This seems to open the door to accidental redocking on
low velockty exits. Shouldn't all initial velocities for docked ships
be radially out from the center of the station, and at an initial
position of at least station radius + ship radius + epison?

* Game option to prevent docking at enemy bases (set at start time of
  either the server or observer) (counts as collision with asteroid
  for damage?)

* Game option to create uranium and vinyl equal to fuel and vinyl
  carried when a ship is blown up.

* Game option to prevent asteroid dust due to collision - if a
  collision happens and you can't pick up and it would result in too
  small due to break, no break.

* Configure number and size of initial asteroids.

1. Add comments throughout on orders:
  * Thrust, Turn, Jettison are mutually exclusive
  * Fire lasers and raise shields be done in any combination with one of the above.

??????????????? Find the questions I asked here ?????????????????

Q. Based on DeepThink's answer to Q1 in our doc fuel and other logic
implicitly assume dt=1.0, but if the simulation is run with other
values velocity and clamping and fuel calculations may be
incorrect. How does this interact with our world being run at 0.2
ticks and then laser blasts on the 1s?

* As cleanup, should we generalize this to tick size and make that a
  global constant or something?

Q. Based on DeepThink's answer to Q2, the acceleration logic may be
flawed, allowing for a final ship velicoty which exceeds maxspeed (I
suspect this would quickly be clamped elsewhere, but... (we could add
a log message if this ever happens somewhere)). Check the facts on
this.

Q. Based on DeepThik's answer to Q3, it claims my two scenarios result
in different costs. get to ground truth on that with a hello world
type example.

Q. Based on DeepThink's answer to Q4, which is basically "this simple
simulation models fuel cost linearly with the angle turned" - think
deep throughts about how you might handle this differently. Our
rotational inertia is set to 0 at the end of each turn, so to turn
theta, we accelerate linearly to 2theta in 1/2 a second and then
decelerate, or something like that. What would that cost in reality
given our ship mass etc. This would be an add on in our "more
realistic physics" package.

Q. Based on DeepThink's answer to Q6/Q7, it agrees dDockDist is kind of stupid, and can create either a walk-out launch wherre we get 5 away each time, or even an infinite loop where we launch with negative velocity.
  Maybe add diagnostic / warning code when we go throug launch cycles? e.g. server announce of each launch and dock and see if we get spammy notices?
  Think deep throughts about:
  * A. What is this even trying to do?
  * B. WOuld it be better to just entirely replace it with a minimum launch distinace of server_radius + ship_radius + fudge factor?
      * Or at least make the launch distance the max of B and what it actually does?

??????????????????????????????????????/

===2===

Add a rule that you can't set jettison orders while docked / you get
back a zero in planning - since you can't jettison while docked why
set the order.
  * NOTE: before changing this consider the implications on subtuns - maybe you can issue a jettison order and then blast off or land or something.

====

Q. Is there a race condition / issue where an asteroid that can't fit
can be blown up multiple times by ships that collide with it on the
same turn?

Q. How are ties broken / resolved in CShip::HandleCollision for
asteroids around like 571 with eating checks? For instance does team1
always get the asteroid if both team1 and team2 are present?

Q. Question 6: What does the default mode of the switch statement on
(ord) in SetOrder do? It looks like maybe it allows you to pass in
O_ALL_ORDERS and get the combined fuel for the: shield, laser, and
thrust operations on the assumption that they all don’t exhaust each
others fuel (which they might in reality).  What do you think the
purpose of this is? Is it used anywhere?

Q. The max laser power in Ship.C's SetOrder seems somewhat arbitrary,
 and forces laser combat to be close up predominantly (can't shoot at
 targets at extreme range without rotating to take the closer shot
 through boundaries, can't pump lots of damage into far ranging
 targets).

Q. Team based pBrain and GetBrain do nothing??!?

Q. Can you mess with other team stuff in your team? Kill their ships,
set their messages? Or is the overall loop: server maintans world,
sends world copies to teams, teams issue orders, server updates world
based on orders, repeat.

Q. (Can you issue orders on other teams ships?  that the server will
do)?


Q. What is going on in the laser shooting code around line 171-181 in
  World.c, why are we adding a distance of 1 of the targets velocity
  onto the lasThing? Is this an effort to impart momentum due to the
  blast, needed to hit the target? To get the damage correct?
  Something else?
    * It seems like this code should be changed and there should be a
  "nudge" in movement away from the laser, perhaps proportional to
  damage taken or whatever.

Q. The logic around adding new things to the world based on MAX_THINGS
is wrong/broken I think. It ends up not mattering because we are at
nowhere near the world limits for the simulation, but for instrance on
line 198 we check and bail if numNewThings>=MAX_THINGS; maybe this is
a sentinel value check with numNewTHings being interpreted as a UINT
with value -1 or something? ACTUALLY - MAYBE THIS IS OK - ITS JUST
WEIRDLY CONTROLLED WITH A numNewThings COUNTER?!?

Q. What is CWorld::SetTeam for? It seems like it's stripping out ships
and stations of the other team? And then adding in the ones for the
new team? Why bother with all this?

Q. What is CWorld::CollisionEvaluation doing - these variable names
suck - why are there two Collide calls on 311/312 with pTItr&pTTM and
the inverse. Fix the dangling unbracketed conditional URes++ on line
313 controlled by prior if.

* The static apTTmTh is way to cute - either make a better data
  structure or just accept the N^2 iteration, this is madness as is.

==1==

In Ship.c, line 592 what is going on with the pointer checks against NULL and the explicit NULL assignment of a data member. The
▌ comment claims it prevents an infinite recursive call.
▌
▌ How does this prevent an infinite recursive call, and is there a better/more standard/less confusing way of managin this situation?

• I’m exploring how temporarily nullifying a ship’s team pointer
  inside HandleCollision in Ship.C prevents infinite recursion when
  two ships collide by blocking symmetrical calls. This clever hack
  tricks the other ship’s collision check into skipping mutual
  collision handling. Still, I’m thinking it might be cleaner to avoid
  mutating team pointers and instead use flags or specialized one-time
  collision handlers to prevent recursive calls and ensure safer, more
  maintainable collision logic.

> - For ship-vs-ship hits, CWorld::CollisionEvaluation already calls
    both orders: shipA->Collide(shipB) and shipB->Collide(shipA).

When shipA reaches CShip::HandleCollision, the block at Ship.C:590 runs only if the other ship reports GetTeam()!=NULL.

- Without the temporary pmyTeam=NULL, shipA would call
  shipB->Collide(shipA), and inside shipB the same block would run
  (because shipA->GetTeam() is still non-null). That would in turn
  call shipA->Collide(shipB) again, producing an infinite ping‑pong.

- Clearing pmyTeam before the call means that, when shipB inspects
  shipA->GetTeam(), it now sees NULL and skips its reciprocal call;
  the guard is purely there to break the recursion. The pointer is
  restored afterward so other logic still sees the real team.

  More conventional ways to handle this would avoid mutating game
  state just to create a guard:

- Add a per-ship reentrancy flag (e.g., bool processingCollision) that
  short‑circuits if already set.

- Let CWorld::CollisionEvaluation call a dedicated symmetric helper
  once per pair (e.g., HandleShipShipCollision(shipA, shipB)) instead
  of bouncing through Collide twice.

- Pass an explicit parameter or use an overload so the second
  invocation knows it’s the mirrored call.

Any of those would be clearer than toggling the team pointer, which is
  easy to misread (and risky if future logic ever observes the NULL
  mid-call).

==end1==

####################### END ENGINE TODO ##########################################

========================== Groonew TODO ============================================

FOR EVOAI - Give it groogroo as a base, and then have the evoai
compete against groonew? Once Groonew is conistently beating groogroo!

0. Consider optimizing initial base launch so we don't all bonk into
each other. Consider initial facing and if it matters which base
you're in. Maybe first 2 turns are always to rotate the ships to cover
an arc towards the center and blast off with max v.

Does it ever make sense to shoot a asteroid to break it up (other than
perhaps action econmy of getting to smaller chunks a tick earlier?)
how much fuel does it take to break it up, versus how much shield do
you lose and how much fuel to restore shield?

How does our n_turns_vector / n_turns thing actually work?, e.g. If
we're moving to the right at 1 unit/sec and we want to be at -5 in

5 seconds, then we need to change our velocity to -1 this turn, or
-6/5 next turn, a change of -2 or -11/5, not a change of -5 (or -6) /
5?

How do collisions and carried over momentum work?

TOROIDTOROIDTOROID
  Q. General nagivation / logic quersions - what happens near edges -
    if we're pursuing something and it is going to be at 513, which is
    -511, do we follow it straight or turn around - does vector
    operations suddenly say it is PI behind us instead of 0 ahead if
    we were heading to it dead on?

0. I definitely need to consider toroidal approaches in perfect
nagivation - getting shortest distance doesn't give shortest time to
intercept - ESPECIALLY with a max speed.
Consider the 1d case where ships are conceptually on a circle of
circumference L:

Dshort <= L/2
Dlong >= L/2
Best time to intecept short = Dshort / (maxspeed - vtarget)
Best time to intercept long = Dlong / (maxspeed - vtarget)

Ignoring some unit confusion above with speed and velocity, the basic
idea is its very easy for the best time to intercept being along the
long path, if the target is moving away from you at close to maxspeed
- even if you pay a 1 turn penalty for turning around and drifting.

TODO: Formally solve this / come up with a formula / logic to pick
direction.
TOROIDTOROIDTOROID

Minor fix: * The 5 1/5th turns thing is going to cause some trouble
too but that should be a fine detail and our gross 1 turn planning
should hold up well-ish.

NOTE: This is not the engine, this is the Ship.C deciding what order
to send to the server for physics resolution!

**************** GROONEW PERFECT NAV ************************************

* See extensive todos and "Steps" in the documentation of determine
  order in Groonew.C and GetVinyl.C for team Groonew.

Consider if a better build out for team groonew involves a hunter ship
with 60 fuel who tries to shoot enemy ships in the early game and base
late game.

* Perfect navigation in Groogroo/MattMatt:
  * Phase 2 - fixes related to 0.2 micro tics between game turns.
  * Handle undocking - the undocking procedure I think gives us a kick
    in position, so our model for where we'll be on turn 1 after
    undocking is wrong with our thurst.
  * Handle negative thrusting and lesser rotations. At least for now
    we don't care what direction we are facing so we should check if
    it's faster to rotate less and then negative thrust.

1. Navigation enhancements: Shortest distance doesn't necessarily mean
fastest time to intercept, and/or cheapest cost. Consider the case
where presently it is only marginally better to go left than right in
terms of distance, however we currently have a large velocity to the
right - we might get there in the same number of turns going right, at
a much reduced cost.

* Think deep thoughts about magic bag, whereby we want to know for N
  turns among all possible paths which ones get to the item with the
  least cost (also possible in the future consider which ones woudl
  generate the least collisions).

* Alternatively, add all the paths to the magic bag and magic bag can
  have multiple things for any target with (path1, nturns, cost),
  (path2, nturns, cost) ,etc. etc.

  * could weight colisions with our station highly as we get free acceleration?
  * Could consider alternate paths in all cases of: go to station and then launch?

* Deep thoughts for future perfect navigation:
  1. Our current approach assumes if you can't reach destination D with
  one rotation and one thurst in T turns you can't reach it at all in
  T turns.
      * This turns out to be false, there are plenty of times when
      thrust-turn-thrust and maybe other approache are better (even
      leaving aside the stuff that happens with thrust governing
      giving us the ability "turn" in the sense we rotate our velocity
      vector in a somewhat controlled manner without issuing the TURN
      order.
  1. DEEP THINK ON OPTIMAL PATHING IN 2D:
     https://docs.google.com/document/d/1_AvkE_JgxQ920-TOI9HCcrU0C_781qOoa-mtjaHXHnM/edit?tab=t.0

* Improve Groonew collision detection in determine_orders - we predict
  where thing X will be in N turns, but we could also check if thing X
  is going to collide with something before N turns, and if so not
  bother trying to intercept it at a place it won't likely to be in
  those turns.

* Improve Groonew collision handling. As it is it iterates over the
  world and locks orders and maybe breaks if it detects certain
  scenarios - but really we want to consider all collisions ordered
  from soonest to latest or something like that. The current logic
  nondeterministically identifies one of the things we're colliding
  with soon and plans based on that - we can do better.

**************** END GROONEW PERFECT NAV ************************************

1. For Codex branch, check if Team Ares is using toroidal logic,
suggest it to use the relevant thing/ship primatives which do that
correctly.

------------------- SYSTEM NOTES -----------------------------------------

What is the inheritance hierarchy for our project:

Asteroid, Laser, Ship, Station IS A Thing

CTeam HAS A:
  * CWorld (pmyWorld)
  * CBrain (pBrain)
  * Array of CShips (apShips)
  * CStation (pStation)

Player teams IS A CTeam

Thing is base class for Asteroid, Ship, Station, and Laser

CShips have:
  * Ship physics:
    * A ships mass is 40 + its fuel + its vinyl
  * Costs and limits (other than default fuel limits)
    * Shield increase 1:1 with fuel spent
    * Lasers cost the value to be fired / 50
    * Thrusting costs the magnitude of the new velocity after the acceleration is applied * current ship mass (see above) / 6*maxspeed*empty_ship_mass = 6*30*40 = 7200. (New velocity vector limited by maxspeed)
      * Thrusting out of a docked position is free, however may be gated based off max fuel size
    * Turning costs the O_TURN provided |value| * ship mass / 12*PI*empty ship mass = 480*Pi - turning SETS THE SHIPS ROTATION TO THE O_TURN AMOUNT IN RADIANS PER SECOND.
    * Jettison costs nothing for vinyl, and the amount jettisoned for fuel.
  * Members: myNum, bDockFlag, dDockDist, dLaserDist, pBrain, arrays of: adOrders, adStatCur, atStatMax
  * Methods (among others like establish capacities):
    * Drift - handles order proceeeing on the ships turn:
      * 1st Jettisons stuff, if any
      * 2nd updates sields, if any
      * Then turns, if any
      * Then thrusts, if any
      * Then updates position
    * AsteroidFits
    * LaserTarget (Purportedly what laserbeam will hit if fired) - does so only if the ship is facing along the shortest straight line path - which is not a catastrophe given our 512 length max laser, but is inconsisntent in that it will report targets that can't be reached (due to short requested laser length or fuel constraints) on the shortest path as we face, but not any (definitionally unreachable due to max beam length) tarets on the longer paths that we face.
      * This logic may in fact be the reason for the 512 max beam length (also a 1024 or larger beam will hit yourself if it hits nothing else)
    * GetLaserBeamDistance (purportedly the distance the beam will traverse)
    * AngleToIntercept - Seems to correctly compute the angle we need to turn to _FACE_ another target next turn taking both our velocites into account, and assuming they stay the same - but this will not do correct vector math I think.
    * AstToStat
    * StatToAst
    * Reset/Get/Set Orders, and special SetJettison/GetJettison
    * HandleCoollision
    * HandleJettison
  
CThings have:
  * Members kind, mass, size, orient, velocity, team, alive, image, name, worldindex, world.
  * Methods:
    * Drift
    * Collide
    * Overlaps
    * GetMomentum (return velocity*mass)
    * DetectCollisionCourse <- fundamentally broken, I changed it (it was using flyby logic which wasn't figuring the closest point of approach - it was more or less estimating if these things would collide if 
    * PredictPosition <- only predicts position, not how we'll be facing
    * RelativeVelocity <- other.velocity - our.velocity
    * RelativeMomentum <- RelativeVelocity * other.mass
    * IsFacing <- True if overlap (buggy due to FP stuff), otherwise establishes a coordinate system with our ship at the origin, and then draws a line on our facing out to DistTo(Other) distance and sees if that point is within the radius of the other object.
    * HandleCollision (virtual)

Physics Engine:

The server's game loop:
while (time < 300.0) { Simulation(); BroadcastWorld(); ReceiveTeamOrders(); }

The team client's game loop:
while (connected) { ReceivedWorld(); DoTurn(); }
  * the Client's DoTurn() gets data
    * calls Team::Reset()
      * The Team::Reset() method calls ResetOrder() on each ship.
    * calls Team::Turn()
      * This method does nothing by default, teams provide their own
        implementation.
    * then sends info back to the server.

SO WE DO ALL OF THIS:
The server's Simulation() does:
  1. The world's PhysicsModel() with a small tstep (0.2) 5 times.
  2. After the 5th call, when 1 second has elapsed, it calls the world's LaserModel() which handles laser collision, adding new and killing dead things.

At each step the PhysicsModel does:
  1. For each thing their Drift(dt) method which is 0.2 in our example
  2. CollisionEvaluation()
  3. AddNewThings()
  4. KillDeadThings()

In the Drift step above:
  1. CShip::Drift:
     * clamps to maxspeed
     * Does orders in this sequence: Jettison, Shields, Turn, Thrust (which in turn will change Vel if a thrust occurs, and change omega of a turn occurs)
     * Changes position and orientation by Vel*dt and omega*dt
     * Sets omega and dLaserDist to zero
  2. Asteroids just do the default CThing behavior of move/rotate dt.
== THEN WE GET NEW ORDERS AND REPEAT ===

Coordinates:

CTraj has a rho (magnitude) and theta (direction):
  * Can ConvertToCort and be created FromCord:
    * Convert to cord makes x = rho*cos(theta) and y follows sin - so "convert to cord" gives you the coordinate this vector points to from the origin.
    * FromCoord also assumes the coordinates are relative to the origin and computes the vector.
  * Normalize() - Keeps -PI < theta < PI and rho  > 0
Notes:
  * Defines const doubles for PI and PI2.

CCord has an x and a y position, and methods:
  * cc.DistTo( occ ) Shortest distance taking toroidal geometry into account
  * cc.AngleTo( occ ) Proper heading for shortest distance taking toroidal geometry into account
  * cc.VectTo( occ ) returns a CTraj object with a vector to the other point
  * cc.Normalize() for putting coordinates into the game field
Notes:
  * Coord.h defines the playing field boundary as -512 to 512 with const doubles fW[X|Y][Max|Min]

=== SERVER / CLIENT LOGIC ===

  Client-Server Architecture

  1. Team Binary Compilation: Each team (like ChromeFunk) is compiled into the mm4team binary. The key is that
   CTeam::CreateTeam() in ChromeFunk.C:10 returns a ChromeFunk instance, linking the team's AI logic into the
  binary.
  2. World State Management:
    - Server maintains authoritative world state (all ships, asteroids, stations)
    - Client receives complete world snapshots via ReceiveWorld() which calls pmyWorld->SerialUnpack()
  (Client.C:166)
    - The initial world creation in Client.C constructor is just placeholder - immediately replaced when
  MeetWorld() connects to server
  3. Game Loop Flow:
  Client (mm4team.C:28-29):
  1. ReceiveWorld() - Get full world state from server
  2. DoTurn() - Execute team AI and send orders back
  4. Team Logic Execution (Client.C:204-217):
    - DoTurn() calls pTm->Turn() which executes ChromeFunk's strategic AI
    - ChromeFunk::Turn() iterates through ships calling pSh->GetBrain()->Decide()
    - Each brain's Decide() sets ship orders (thrust, turn, fire, etc.)
    - Orders are packed via SerialPack() and sent to server
  5. State Synchronization:
    - From Server: Full world state including all ship positions/velocities/cargo/shields
    - To Server: Only ship orders (thrust amount, turn amount, fire commands)
    - Server simulates physics and combat, then broadcasts updated world state

  The team AI (ChromeFunk) never directly modifies world state - it only reads state and generates orders. The
   server is authoritative for all physics and game state changes.

  One Time Team Initialization Protocol

  When a team client connects (Client.C:129-135), it:

  1. Calls Init() - Team sets names and capacities (ChromeFunk.C:36-56):
    - Team name: "Chrome Funkadelic"
    - Station name: "HeartLand"
    - Ship names: "SS TurnTable", "Bell Bottoms", etc.
    - Ship capacities: 45.0 fuel, 15.0 cargo
  2. Packs initialization data via SerPackInitData() (Team.C:243-272) which sends:
    - Team number
    - Team name
    - Station name
    - For each ship:
        - Cargo capacity
      - Fuel capacity
      - Ship name
  3. Server receives and unpacks this data using SerUnpackInitData() (Team.C:274-307), which:
    - Sets all the names on server-side objects
    - Configures ship capacities
    - Initializes fuel to max capacity and shields to 15.0

  This is a one-time handshake during connection. After this, the server knows all team/ship/station names and
   ship capacities, allowing it to:
  - Enforce cargo limits during pickup operations
  - Track fuel consumption based on configured capacity
  - Display correct names in observer views
  - Manage team-specific station operations

  The team binary configures these values in Init(), but they're immediately transmitted to and stored by the
  server, which becomes the authoritative source for all game mechanics involving these properties.

==== ChromeFunk Brain Approach ====

The CBrain hierarchy in ChromeFunk demonstrates a context-switching AI pattern using
  temporary brain replacements. Here's the design:

  Brain Hierarchy

  CBrain (base class)
  ├── Voyager    - Station departure specialist (temporary)
  ├── Stalker    - Navigation/interception
  ├── Shooter    - Combat (inherits from Stalker)
  └── Gatherer   - Resource collection (inherits from Shooter)

  The Brain-Swapping Pattern

  The key insight is in Voyager (lines 43-54, 56-81):

  1. Temporary replacement: Voyager stores the previous brain (pLastBrain) and installs itself
  2. Self-deletion: Once undocked, Voyager deletes itself, automatically restoring the previous
   brain via its destructor
  3. Example flow: Gatherer → Voyager → Gatherer

  This happens in Gatherer::Decide() at line 343:
  if (pShip->IsDocked()) {
      new Voyager(this);  // Creates Voyager, which replaces Gatherer temporarily
      return;             // Voyager handles departure, then restores Gatherer
  }

  Requirements That Led to This Design

  This implementation suggests these requirements:

  1. Specialized behaviors: Different tasks need completely different decision logic (docking
  vs combat vs gathering)
  2. State preservation: Ships need to return to their previous behavior after temporary tasks
  3. Clean transitions: No complex state machines or if/else chains cluttering the main logic
  4. Reusable components: Shooter extends Stalker, Gatherer extends Shooter - building
  complexity through inheritance
  5. Self-managing contexts: Behaviors know when they're done and clean up after themselves

  The pattern allows ships to have a "stack" of behaviors - push a temporary brain for special
  situations (like undocking), then pop back to the previous behavior automatically. It's
  elegant for handling context switches without losing the ship's primary mission.

===============

Dubins' Result: The shortest path between any two positions+orientations is one of only 6 types:

LSL, RSR, LSR, RSL, RLR, LRL

Advanced: Reeds-Shepp Vehicle
Like Dubins but can reverse:

Adds backward segments
48 types of optimal paths instead of 6
Used for parking, tight maneuvering

==============

------------------------------- END NOTES ----------------------------------------------------

QAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQAQA

Q. Can you cheat by setting things like ship velocity, asteroid size,
base vinyl, etc.?
A. You can set these things, but your team is running in a client
which gets a private version of the world each tick from the
server. The server recieves your orders and processes physics based on
them, and resends the updated world, so you can't cheat this way.

Q. Can you cheat by manipulating the raw orders set rather than using
SetOrder?
A. Yes, with limited success: you can create a derived class of CShip
that has no private data members (and hence the same memory layout as
CShip) with members that cast a CShip via C style casting or
reinterpret cast to be your derived class and return pointers to the
undostats and order arrays for direct manipulation, however:
  * adStat values are ignored by the server from the client's data
  * adOrders are processed - so you can do things like set multiple
    orders or set magnitudes you wouldn't have been allowed to, but
    the server then replays most of orders through the Ship.C's
    SetOrders which enforces the rules. It is possible you could
    trigger a corner case here, but the design of SetOrders is
    intended to be robust against this.
  * However, the legacy engine implementation of LaserModel does allow
    an exploit here - it powers the laser with whatever has been set
    in the order, and fires it with that amount, and only later does
    it deduct fuel.

Q. Can you cheat by issuing multiple commands whose combined fuel cost
exceeds available fuel but still get their benefits?

A. Generally no - but there is again a special case with the Laser
implementation. The legacy engine will effectively do this:
1. Raise shields by full requested amount, deducting the fuel required.
2. Do the first subtick (0.2) seconds of Thurst or Turn if one is specified, deducting the fuel required.
3. Shoot lasers based on the input command value, then figure fuel.
4. Do the remainin subticks of Thurst/Turn.
In step 3 you can exceed your fuel alotment - especially if you raised
shields. Lasers are effectively "free" on any turn where you'd run out
of fuel before the 2nd physics tick anyway.

================== END Q&A ===========================================


