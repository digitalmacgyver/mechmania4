# Sound System Status

## Project Goals
- Deliver a reliable SDL_mixer based audio stack that can run headless or with full observer UI.
- Keep soundtrack and effects flexible via `sound/defaults.txt`, supporting per-team overrides and behaviour hints (queue, delay, scale).
- Ensure the observer UI exposes intuitive audio controls (mute toggles, diagnostics, future playlist control) while respecting command-line flags.

## In Progress
- **World-driven effect emission**
  - Ensure remaining gameplay events emit `CWorld::LogAudioEvent()` calls (e.g., game-end summaries still pending richer metadata).
  - Confirm new game outcome IDs (`team#.game_lost.default`) follow a consistent naming scheme across replays and remote observers.
- **Default configuration refinements**
  - Document manual namespace keys (e.g., `manual.menu.toggle_enabled_alt`) for UI code to reference.
- **Observer audio UX**
  - Track context is now displayed; add tooltip/legend updates so help footer also references the `[X]` shortcut.
  - Collect feedback on the alternating menu clicks to confirm they feel responsive when spammed while muted.

## Remaining TODOs
- **Menu interaction sounds**
  - Hook into UI events:
    - Keyboard shortcuts (`SDLK_m`, `SDLK_e`) now call `PlayMenuToggleSound(MenuToggleControl::kMusic|kEffects, !mute)`; keep future UI buttons (if any) pointed at the same helper.
    - Hook observer UI widgets to the same helper when they are added.
  - Implement “first click after enabling effects should play even if effects were muted” rule: detect rising edge of effects mute; play a single confirmation using `manual.menu.toggle_enabled` then suppress until unmuted again.
  - Queue manual events via `AudioSystem::QueueEffect()` using `manual.menu.*` logical IDs (no team index).
- **Soundtrack management**
  - Persist playlist seed/ordering to the server log so replay desyncs are debuggable; expose CLI knob for deterministic seed overrides.
  - Add observer-side command palette (or HUD overlay) to display the next few tracks in queue using `PlaylistSnapshot()`.
  - Gate track advancement when music is muted so that unmuting resumes at the newly selected track without flashing audio.
  - Exercise `NextTrack(true)` and auto-advance paths in an automated harness (headless observer run) to confirm hooks still fire after pause/resume and server reconnects.
- **Observer startup polish**
  - When `--mute` used, ensure footer indicators render muted state immediately (update `DrawAudioControlsPanel` to read `startAudioMuted_` on first draw).
  - Defer first menu sound until effects unmuted by caching a `menuMutedAck_` flag; synthesise a single `manual.menu.toggle_enabled` click when user unmutes.
  - Expose current music/effects mute status in the on-screen help (e.g., “Soundtrack: MUTED (M)”).
- **Testing & tooling**
  - Extend `build/quick_test.sh` or new script to run observer in headless mode with `--verbose --mute` and assert presence of audio logs (`[audio] music next track`, `schedule event=team1.launch...` etc.).
  - Add unit-ish coverage: craft a small integration harness that instantiates `CWorld`, triggers events (launch, dock, deliver), and verifies `GetAudioEvents()` contents.
  - Update docs (`README_MODERNIZED.md`) with new CLI flag and QA checklist: menu toggles, cycle soundtrack, mute/unmute flows.
  - Link the new `docs/SOUND.md` overview into `README_MODERNIZED.md` once ready.
